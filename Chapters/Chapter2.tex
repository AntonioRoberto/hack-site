% Chapter 2

\chapter{Divisibilidade} % Main chapter title

\label{Chapter2} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Divisibilidade}
A noção de divisibilidade dos números inteiros é fundamental na \textbf{Teoria dos Números}.
Nesta seção vamos descrever algumas definições e propriedades que serão utilizadas ao longo desse trabalho.

\begin{definition}
A notação $d|n$ ("$d$ \textbf{divide} $n$"), significa que existe um inteiro $q$, tal que, $n = dq$.
Se $d|n$ dizemos que $n$ é múltiplo de $d$. Caso $n$ não seja múltiplo de $d$ (ou seja, $d$ não divide $n$), escrevemos $d \nmid n$.
\end{definition}

\begin{definition}
A notação $d\bmod n$ ("$d$ \textbf{módulo} $n$"), significa o resta da divisão de $d$ por $n$.
\end{definition}

\begin{proposition}\label{divisibilidade_transitiva}
$d|n$ , $d|m \Rightarrow d|(n+m)$
\end{proposition}
\textbf{Demonstração:}
Se $d|n$ e $d|m$, então existem inteiros $q$ e $k$, tal que, $n = qd$ e $m = kd$. Desse modo temos:

$(n+m) = qd + kd = (q + k)d \Rightarrow d|(n+m) $ $\square$


\begin{proposition}\label{divisibilidade_fracao}
$d|(\frac{n}{m}) \Rightarrow dm|n$
\end{proposition}
\textbf{Demonstração:}

$d|(\frac{n}{m}) \Rightarrow \exists q \in \mathbb{Z} \mid \frac{n}{m} = qd$

$d|(\frac{n}{m}) \Rightarrow n = q(dm) \Rightarrow dm|n$ $\square$


\begin{proposition}\label{corolario_divisibilidade_1}
Dado um subconjunto dos inteiros $S = \{S_1, S_2, S_3, ..., S_n\}$ ordenado crescentemente, e um número inteiro $d$, tal que, $d|(S_i-S_{i-1})$, $2 \leq i \leq n$, 
temos que: 

$d|(S_i-S_j)$, $\forall S_i, S_j \in S$.

\end{proposition}
\textbf{Demonstração:}
Tome $S_i,S_j \in S$ quaisquer, e sem perda de generalidade assuma que $S_i \geq S_j$ (ie, $i \geq j$, pois $S$ está ordenado crescentemente).

Como $i \geq j$, tome $r \in \mathbb{N}$ como sendo a diferença entre $i$ e $j$ : $i = j + r$.

Vamos agora provar por indução que $d|(S_{j+r}-S_j)$.

Para $r=0$ ou $r=1$ a demonstração segue trivialmente.

Assuma que o corolário funciona para $(r-1)$, ie, $d|(S_{j+r-1}-S_j)$. 

Temos então que: 

$d|(S_{j+r}-S_{j+r-1}) \Rightarrow d|(S_{j+r}-S_{j+r-1})+(S_{j+r-1}-S_j)$ ($\triangleright$ \textbf{Proposição} \autoref{divisibilidade_transitiva})

$d|(S_{j+r}-S_{j+r-1}) \Rightarrow d|(S_{j+r}-S_j)$ $\square$ 


\begin{proposition}\label{corolario_divisibilidade_1.1}
A \textbf{Proposição} \autoref{corolario_divisibilidade_1} funciona mesmo se o conjunto $S$ não estiver ordenado.
\end{proposition}
\textbf{Demonstração:}
Deixaremos a demonstração a cargo do leitor.
\newline

\begin{definition}
A operação \textbf{módulo} de dois inteiros $a$ e $b$, dada por "$a \bmod b$", representa o resto da divisão de $a$ por $b$.
\end{definition}

\begin{theorem}[Teorema da Divisão]\label{algoritmo_divisao}
Para todo número inteiro $a$ e qualquer número inteiro positivo $n$, existem inteiros únicos $q$ e $r$, tal que:

$a = qn + r$, $0 \leq r < n$

O valor $q$ ($q = \lfloor  \frac{a}{n} \rfloor$) é chamado de \textbf{quociente} da divisão, e o valor $r$ ($r = a \bmod n$) é chamado de \textbf{resto}
(ou \textbf{resíduo}) da divisão.
\end{theorem}
\textbf{Demonstração:}
Suponha que $q$ e $r$ não sejam únicos, ie, que exista $q^*$ e $r^*$ tal que: $a = q^*n + r^*, 0 \leq r^* < n$.

$a = qn + r = q^*n + r^* \Rightarrow (r - r^*) = (q^* - q)n \Rightarrow n|(r - r^*)$ já que $n|(q^* - q)n$.

Porém, como $r \neq r^*$, e tanto $r$ quanto $r^*$ são menores que $n$, temos que: 

$(r\bmod n) \neq (r^*\bmod n) \Rightarrow n \nmid (r - r^*)$.

Chegando numa contradição, e assim $q$ e $r$ são únicos. $\square$ \\

\begin{corollary}\label{divisibilidade_modular}
$d|n$ , $d|m \Rightarrow d|(n \bmod m)$
\end{corollary}
\textbf{Demonstração:}

$d|n \Rightarrow n = k_1d, k_1 \in \mathbb{Z}$

$d|m \Rightarrow m = k_2d, k_2 \in \mathbb{Z}$

$n = qm + (n \bmod m) \Rightarrow (n \bmod m) = n - qm$ ($\triangleright$ \autoref{algoritmo_divisao})

$(n \bmod m) = k_1d - qk_2d = (k_1 - qk_2)d \Rightarrow d|(n \bmod m)$ $\square$


\begin{corollary}\label{divisibilidade_modular2}
$d|m$ , $d|(n \bmod m) \Rightarrow d|n$
\end{corollary}
\textbf{Demonstração:}

$d|m \Rightarrow m = k_1d, k_1 \in \mathbb{Z}$

$d|(n \bmod m) \Rightarrow (n \bmod m) = k_2d, k_2 \in \mathbb{Z}$

$n = qm + (n \bmod m) \Rightarrow n = qk_1d + k_2d$ ($\triangleright$ \autoref{algoritmo_divisao})

$n = (qk_1 + k_2)d \Rightarrow d|n$ $\square$


\subsection{Divisores}
Nessa subseção mostraremos um algoritmo simples para calcular todos os divisores de um dado número inteiro positivo qualquer.

\begin{theorem} 
O número de divisores de $n \in \mathbb{Z}^{+}$ é da ordem de $O(\sqrt{n})$.
\end{theorem}
\textbf{Demonstração:}
Tome um divisor $d$ de $n$ qualquer, com $d > \sqrt{n}$. Dessa forma sabemos que existe um inteiro $q$, tal que $n=qd$ (observe que $q$ também é divisor de $n$). 
Como $d > \sqrt{n}$ então $q < \sqrt{n}$. Assim, para qualquer divisor $d$ de $n$ maior que $\sqrt{n}$, existe exatamente um divisor $q$ de $n$ menor que $\sqrt{n}$ correspondente ao mesmo.
O que implica que só existem no máximo $\sqrt{n}$ divisores maiores que $\sqrt{n}$. Por outro lado, claramente só existem $\sqrt{n}$ divisores menores que $\sqrt{n}$.
Concluímos então que o número total de divisores de $n$ é da ordem de $O(\sqrt{n})$. $\square$
\\

\clearpage
\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Encontra todos os divisores de N}\label{encontra_divisores}
\begin{algorithmic}[1]
\Procedure{FindDivisors (N)}{}
\State $D \gets \emptyset$ \Comment{Conjunto $D$ contém os divisores de $N$}

\For {($d = 1 \text{; } d^2 \leq N \text{; } d++)$}

\If {$d\nmid N$}
\State \textbf{continue}
\EndIf
\State $D \gets D \cup \{d\}$
\State $q \gets \frac{N}{d}$
\If {$q\neq d$}
\State $D \gets D \cup \{q\}$
\EndIf

\EndFor

\State \Return{$D$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O laço da linha 3 consome tempo  $O(\sqrt{N})$, testando se os números menores que $\sqrt{N}$ são divisores. Na linha 7 são calculados os divisores correspondentes maiores 
que $\sqrt{N}$. E a condição da linha 8 garante que se $N$ for quadrado perfeito, então é inserido $\sqrt{N}$ somente uma vez no conjunto $D$.
Assim a complexidade total do algoritmo é $O(\sqrt{N})$.




%-----------------------------------
%	SECTION 2
%-----------------------------------
\section{Números Primos}

\begin{definition} 
Todo número inteiro n (n > 1) que têm apenas dois divisores distintos (1 e n) é chamado de número primo. Se n (n > 1) não for primo, dizemos que n é número composto.
\end{definition}


\begin{theorem}[Fatoração Única]\label{fatoracao_unica}
Um número natural qualquer $n>1$, pode ser escrito unicamente como um produto da forma: 
$n = p_1^{a_1}p_2^{a_2}...p_k^{a_k}$, onde os $p_i$ são números primos, $p_1 < p_2 < ... < p_k$, e os números $a_i$ são inteiros positivos.
\end{theorem}
\textbf{Demonstração:}
Primeiro vamos mostrar que existe tal fatoração para um inteiro $n$ qualquer. Se $n$ for primo, então $n$ já está fatorado. 
Se $n$ for composto, então existe um primo $p$ que divide $n$, ie, $n=pq$. Se $q$ for primo então $n$ estará fatorado,
 ou $n = p^1q^1$ ou $n = p^2$ (se $p=q$).
Caso $q$ não seja primo, repetimos o mesmo processo para $q$, de modo que teremos uma fatoração de $q$ no final do processo, e por
consequência uma fatoração de $n$.

Para mostrar a unicidade, tome as duas fatorações de $n$, $p_1^{a_1}p_2^{a_2}...p_k^{a_k}$ e $q_1^{b_1}q_2^{b_2}...q_r^{b_r}$.
Por definição temos, $p_1 < p_2 < ... < p_k$ e $q_1 < q_2 < ... < q_r$. 

Se $k<r$ então existe um primo em $\{q_1,q_2,...,q_r\}$ que divide $n$, mas não aparece na fatoração $p_1^{a_1}p_2^{a_2}...p_k^{a_k}$,
chegando numa contradição. Analogamente, podemos provar que se $k>r$ chegaremos em outra contradição. E assim, concluímos que $k=r$.

Por outro lado, todo primo que aparece na primeira fatoração deve também aparecer segunda fatoração (e vice versa). Pelo fato das
fatorações estarem ordenadas, teremos que $p_i = q_i$, $1\leq i\leq k$.



 Como a primeira fatoração divide a segunda fatoração e vice versa, temos também que $a_i = b_i$, $1\leq i\leq k$. $\square$





%-----------------------------------
%	SECTION 3
%-----------------------------------
\section{Máximo Divisor Comum}

\begin{definition}
O Máximo Divisor Comum de dois inteiros quaisquer $a$ e $b$ (com a ou b diferente de zero), denotado por $MDC(a,b)$, é o maior inteiro que divide ambos $a$ e $b$. 
Se $MDC(a,b) = 1$ dizemos que $a$ e $b$ são primos entre si.

Por definição, temos também que $MDC(a,0) = a$.
\end{definition}


\begin{corollary}\label{gcd_modular}
Para números inteiros quaisquer $a$ e $b$, $MDC(a,b) = MDC(b, a \bmod b)$
\end{corollary}
\textbf{Demonstração:}
Pelo \textbf{Corolário} \autoref{divisibilidade_modular} e \autoref{divisibilidade_modular2}, temos:

$d|a, d|b \Leftrightarrow d|b, d|(a \bmod b)$

Assim, qualquer divisor de $a$ e $b$ é também divisor de $b$ e $(a \bmod b)$ (e vise versa), implicando que o \textbf{Máximo Divisor Comum} de $a$ e $b$
é igual ao \textbf{Máximo Divisor Comum} de $b$ e $(a \bmod b)$. $\square$



\begin{proposition}\label{divisibilidade_mdc}
$MDC(a,b) = d \Rightarrow MDC(\frac{a}{d}, \frac{b}{d}) = 1$
\end{proposition}
\textbf{Demonstração:}
Para $d = 1$, a prova é trivial.

Suponha que $MDC(\frac{a}{d}, \frac{b}{d}) = r > 1$. Assim temos:

$r|\frac{a}{d} \Rightarrow dr|a$ ($\triangleright$ \textbf{Proposição} \autoref{divisibilidade_fracao})

$r|\frac{b}{d} \Rightarrow dr|b$ ($\triangleright$ \textbf{Proposição} \autoref{divisibilidade_fracao})

$r > 1 \Rightarrow dr > d \Rightarrow dr > MDC(a,b)$

Chegamos então numa contradição, pois $dr$ é divisor comum de $a$ e $b$, e $dr$ é maior que o \textbf{Máximo Divisor Comum} de $a$ e $b$. $\square$



\begin{proposition}\label{corolario_gcd_soma}
Para números inteiros quaisquer $a$ e $b$, $MDC(a,b) = MDC(a,a \pm b)$
\end{proposition}
\textbf{Demonstração:}
A prova dessa expressão vem do fato de que qualquer divisor de $a$ e $b$, é também divisor de $(a \pm b)$.



\begin{proposition}\label{corolario_gcd_produto}
Para números inteiros quaisquer $a$ e $b$, temos:

$MDC(a,b) = 1 \Rightarrow MDC(a,bk) = MDC(a,k)$, com $k \in \mathbb{Z}$
\end{proposition}
\textbf{Demonstração:}
A prova dessa expressão vem do fato de que qualquer divisor $d$ de $a$ e $bk$, é também divisor de $k$, pois $d$ não divide $b$ ($MDC(a,b) = 1$).
\\

\begin{corollary}\label{mdc_primo_fatorial}
$MDC((p-1)!, p)=1$, para $p$ primo qualquer.
\end{corollary}
\textbf{Demonstração:}
Tome um inteiro positivo $d < p$. Como $p$ é primo, sabemos que $MDC(p,d)=1$, ie, $d$ não tem nenhum fator primo em comum com $p$. Assim
o produto $(p-1)!$ de todos os inteiros positivos menores que $p$ também não terá nenhum fator primo em comum com $p$. $\square$
\\



\subsection{Algoritmo de Euclides}\label{algoritmo_de_euclides_subsessao}
A ideia principal do \textbf{Algoritmo de Euclides} é calcular recursivamente o \textbf{Máximo Divisor Comum} de dois números baseando-se no 
\textbf{Corolário} \autoref{gcd_modular}.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Algoritmo de Euclides}\label{mdc}
\begin{algorithmic}[1]
\Procedure{$MDC (a, b)$}{}
\If {$b = 0$}
\State \Return $a$
\EndIf
\State \Return $MDC(b, a \bmod b)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Primeiro provaremos a corretude do algoritmo fazendo uma indução sobre o número de chamadas recursivas $N$.

Se $N=0$, então $b=0$, e desse modo $MDC(a,0)=a$, ie, para esse caso base o algoritmo retorna o valor correto.

Agora assuma que $MDC(a,b)$ faça $N>0$ chamadas recursivas. Pela hipótese de indução a chamada $MDC(b, a \bmod b)$ retorna o valor correto. Pelo \textbf{Corolário} \autoref{gcd_modular} sabemos que $MDC(a,b) = MDC(b, a \bmod b)$, provando assim a corretude do algoritmo.

Agora faremos uma análise da complexidade do algoritmo.

O \textit{Algoritmo de Euclides} consome tempo proporcional à $O(\log b)$. Para provar a análise do custo do algoritmo é preciso conhecer algumas propriedades da \textit{Sequência de Fibonacci}, e desse modo, a 
demonstração será feita no \textbf{Capítulo 3}, \textbf{Subseção 3.2.1}.



\subsection{Teorema de Bézout}

\begin{proposition}\label{bezout_conjunto_nao_nulo}
Seja o conjunto de combinações lineares positivas $S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$, onde os números $a$ e $b$ são inteiros, 
e pelo menos um desses números é diferente de zero. Temos então que $S \neq \emptyset$. 
\end{proposition}
\textbf{Demonstração:}
As combinações possíveis para $a$ e $b$ são:

$a > 0 \Rightarrow |a| = 1.a + 0.b$

$a < 0 \Rightarrow |a| = (-1).a + 0.b$

$b > 0 \Rightarrow |b| = 0.a + 1.b$

$b < 0 \Rightarrow |b| = 0.a + (-1).b$

Como não temos ambos $a$ e $b$ iguais à zero, então $S$ deve conter pelo menos $|a|$ ou $|b|$, e assim $S \neq \emptyset$ $\square$


\begin{corollary}\label{bezout_conjunto_divide}
Seja o conjunto de combinações lineares positivas $S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$, onde os números $a$ e $b$ são inteiros, 
e pelo menos um desses números é diferente de zero. Temos então que o menor número $d \in S$ divide todos os elementos de $S$.
\end{corollary}
\textbf{Demonstração:}
Como $d \in S$, $\exists m,n\in\mathbb{Z} \mid d = ma + nb$.

Tome $x \in S$ qualquer. Pelo \autoref{algoritmo_divisao} $x = qd + r$, $0 \leq r < d$.

Suponha que $d\nmid x$, ie, $x \neq qd$ e $0 < r$. Como $x \in S$, $\exists m^*,n^*\in\mathbb{Z} \mid x = m^*a + n^*b$, e assim:

$x = m^*a + n^*b, x = qd + r \Rightarrow r = m^*a + n^*b - qd = m^*a + n^*b - q(ma + nb)$ 

$\Rightarrow r = (m^* - qm)a + (n^* - qn)b \Rightarrow r \in S$, pois $r > 0$

Chegamos numa contradição, pois $r \in S$, $d \in S$, $r < d$ e $d$ é o menor elemento em $S$.

Desse modo, temos que $d$ divide todos os elementos de $S$. $\square$


\begin{theorem}[Teorema de Bézout]\label{teorema_bezout}
$\forall$ $a$, $b \in \mathbb{Z}$ (com pelo menos um dos dois números diferente de zero), $\exists$ $x, y \in \mathbb{Z} \mid ax + by = mdc(a, b).$
\end{theorem}
\textbf{Demonstração:}
Tome o conjunto das combinações lineares de $a$ e $b$:

$S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$.

Pelo \textbf{Proposição} \autoref{bezout_conjunto_nao_nulo} sabemos que $S \neq \emptyset$. Como $S$ contém somente números positivos e não é vazio, 
$S$ está limitado inferiormente por \textit{zero} e assim, $S$ tem um elemento mínimo que chamaremos de $d$.

Como $d \in S$, então existe $u, v\in \mathbb{Z}$, tal que, $d = ua + vb$. Pelo \textbf{Corolário} \autoref{bezout_conjunto_divide}, sabemos que $d$ divide todos elementos em $S$, em particular:

$d$ divide $|a|$ e $|b| \Rightarrow d|MDC(a,b) \Rightarrow 0 < d \leq MDC(a,b)$

Por outro lado, $MDC(a,b)$ também divide $a$ e $b$:

$MDC(a,b)|a$ e $MDC(a,b)|b \Rightarrow MDC(a,b)|(ua + vb)$

$ \Rightarrow MDC(a,b)|d \Rightarrow MDC(a,b) \leq d$

$MDC(a,b)\leq d$ e $d \leq MDC(a,b) \Rightarrow MDC(a,b) = d \Rightarrow MDC(a,b) \in S$ $\square$





%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Crivo de Erastóteles}

O \textit{Crivo de Erastótenes} é um algoritmo criado pelo matemático \textbf{Erastótenes} (a.C. 285-194 a.C.) para o cálculo de números primos
até um certo valor limite $N$.
O algoritmo mantém uma tabela com $N$ elementos, e para cada primo, começando pelo número $2$, marca na tabelo os números compostos múltiplos desses primos.
Desse modo, ao final do algoritmo, os elementos não marcados são números primos.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Crivo de Erastótenes paro o cálculo de números primos}\label{crivo_erastotenes}
\begin{algorithmic}[1]
\Procedure{CrivoErastótenes (N)}{}
\State $isPrime[] \gets \text{new Array}[N]$ \Comment{$isPrime[]$ é um vetor booleano}
\State $isPrime[1] \gets false$
\\
\For {($p = 2 \text{; } p \leq N \text{; } p++)$}
\State $isPrime[p] \gets true$
\EndFor
\\
\For {($p = 2 \text{; } p^2 \leq N \text{; } p++)$}
\If {$isPrime[p] = false$}
\State \textbf{continue}
\EndIf
\For {($n = p^2 \text{; } n \leq N \text{; } n = n+p)$}
\State $isPrime[n] \gets false$
\EndFor
\EndFor
\\
\State \Return{$isPrime[]$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Primeiro provaremos a corretude do algoritmo. Para isso provaremos que ao final do algoritmo teremos a seguinte implicação:
$isPrime[n] = false \Leftrightarrow n$ é composto.

Todos os valores que $n$ assume no laço da linha $11$ são múltiplos de $p$, e assim temos que: $isPrime[n] = false \Rightarrow n$ é composto.

Agora tome um $n$ composto qualquer menor que $N$. Sabemos que existe um primo $q \leq \sqrt{n} \leq \sqrt{N}$ que divide $n$. 
E desse modo, em uma das iterações do laço da linha $8$ teremos $p=q$. Como $q$ é primo então $isPrime[q]=true$, e desse modo
o laço da linha $11$ será executado, iterando sobre os múltiplos de $q$ menores que $N$, ie, em alguma iteração será executada 
a operação $isPrime[n]\gets false$, implicando assim em: $isPrime[n] = false \Leftarrow n$ é composto.

Agora faremos uma análise da complexidade do algoritmo.

O laço da linha $4$ itera sobre todos os valores de $2$ até $N$ e assim consome tempo $O(N)$.
Já o laço mais interno na linha $9$ itera sobre todos os números entre $p^2$ e $N$ que são múltiplos de $p$, e assim consome tempo
$O(N/p)$. 

Desse modo a complexidade conjunta dos laços das linhas $6$ e $9$, será $O(\sum_{p \text{ primo | }p\leq sqrt(N)} \frac{1}{p})$
(observe que o laço da linha $6$ itera sobre os primos menores que $sqrt(N)$). 

Como foi sugerido por \textit{Leonhard Euler} no século XVIII, temos que $\sum_{p \text{ primo | }p\leq sqrt(N)} \frac{1}{p} = O(N\log \log N)$. E assim a complexidade final do algoritmo é $O(N \log \log N)$.
%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Equações Diofantinas}

\textit{Equações Diofantinas} são equações polinomiais com variáveis inteiras. Alguns exemplos são mostrados a seguir, sendo $x$, $y$, $z$ incógnitas, e $a$, $b$, $n$ constantes inteiras:

$ax + by = n$ ($\triangleright$ \textit{Equação Diofantina Linear})

$ax + by = MDC(a,b)$ ($\triangleright$ \textit{Identidade de Bézout})

$x^n + y^n = z^n$ ($\triangleright$ Equação base do \textit{Último Teorema de Fermat})

$x^2 - ny^2 = \pm 1$ ($\triangleright$ \textit{Equação de Pell})\\



Nesse trabalho abordaremos somente \textit{Equações Diofantinas Lineares}, da forma:

$\sum_{i=1}^{k}a_i x_i = c$

onde $c$ e $a_i$ são constantes, e $x_i$ variáveis inteiras.\\


\begin{theorem}\label{equacao_diofantina_implicacao}
Dados inteiros $a$, $b$, $c$ , temos que:

$MDC(a,b)|c \Leftrightarrow$ a \textit{Equação Diofantina} $ax + by=c$, tem solução inteira.
\end{theorem}
\textbf{Demonstração:}
Provaremos primeiro a ida da implicação.

Pelo \autoref{teorema_bezout} sabemos que existem inteiros $x^*$ e $y^*$, tal que, $ax^* + by^* = MDC(a,b)$. Logo:

$MDC(a,b)|c \Rightarrow \exists! q\in\mathbb{Z} \mid c = MDC(a,b)q \Rightarrow a(x^*q) + b(y^*q) = MDC(a,b)q = c$ 

Provaremos agora a volta da implicação.

Sabemos que existem inteiros $u$ e $v$, tal que, $a=MDC(a,b)u$ e $b=MDC(a,b)v$. Logo:

$ax + by=c$, tem solução inteira $\Rightarrow MDC(a,b)ux + MDC(a,b)vy = c$

$\Rightarrow MDC(a,b)(ux + vy) = c \Rightarrow MDC(a,b)|c$. $\square$ 


%----------------------------------------------------------------------------------------

\subsection{Algoritmo de Euclides Estendido}

\textit{Algoritmo de Euclides Estendido} é uma extensão do \textit{Algoritmo de Euclides} que calcula não só o $MDC(a,b)$, para dados $a$ e $b$, mas também encontra
uma solução para a \textit{Identidade de Bézout} $ax+by = MDC(a,b)$. 
\clearpage

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Algoritmo de Euclides Estendido}\label{mdc_extended}
\begin{algorithmic}[1]
\Procedure{$ExtendedMDC (a, b)$}{}
\If {$a = 0$}
\State \Return $[b,0,1]$
\EndIf
\\
\State $[d,x,y] \gets ExtendedMDC(b \bmod a, a)$
\State $x^* \gets y - \lfloor \frac{b}{a} \rfloor x$
\State $y^* \gets x$
\State \Return $[d,x^*,y^*]$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Primeiro mostraremos a corretude do algoritmo.

Em vez de retornar um inteiro, $ExtendedMDC(a,b)$ retorna uma tupla $[d,x,y]$, onde $d=MDC(a,b)$ e $x$,$y$ são a solução da equação $ax+by=d=MDC(a,b)$.
Sabemos que $[d,x,y]$ na linha $5$ satisfaz a equação, $(b\bmod a)x + ay = d$, assim:

$(b\bmod a)x + ay = d \Rightarrow (b - \lfloor \frac{b}{a} \rfloor a)x + ay = d$

$\Rightarrow a(y-\lfloor \frac{b}{a} \rfloor x) + b(x) = ax^* + by^* = d = MDC(a,b)$

Observe que o \textit{Algoritmo de Euclides Estendido} é baseado no \textit{Algoritmo de Euclides}, tendo a mesma complexidade $O(\log(a+b))$.
\\


\begin{corollary}\label{mdc_extended_solutions}
Tome $[d,x_0,y_0]$ como sendo a tupla retornada pelo $ExtendedMDC(a,b)$, com $a$, $b$, $c$ inteiros e $MDC(a,b)|c$.
Então temos que todas as soluções da equação $ax+by=c$ são da forma: $x=(x_0\frac{c}{d} + \frac{bq}{d})$, $y=(y_0\frac{c}{d} - \frac{aq}{d})$, em que $q\in\mathbb{Z}$.
\end{corollary}
\textbf{Demonstração:}
Pelo \textit{Algoritmo de Euclides Estendido} sabemos que $ax_0 + by_0=d$. Sabemos também que $d|c$ por definição, ie, existe $k\in\mathbb{Z}$ tal que $c=kd$.
Assim temos que $x=x_0k$ e $y=y_0k$ é solução, já que $a(x_0k)+b(y_0k) = kd = c$. 

Agora tome a solução $x^*,y^*$ qualquer ($ax^*+by^*=c$). Subtraindo as últimas duas equações temos:
\\

$a(x_0k-x^*) + b(y_0k-y^*) = 0 \Rightarrow a(x_0k-x^*) = b(y^* - y_0k) \Rightarrow a|[b(y^* - y_0k)]$

$\Rightarrow \frac{a}{MDC(a,b)}|(y^* - y_0k) \Rightarrow \exists! q\in\mathbb{Z}$, tal que $\frac{a}{MDC(a,b)}q = (y^* - y_0k)$

$\Rightarrow y^* = y_0k + \frac{a}{MDC(a,b)}q \Rightarrow y^* = y_0\frac{c}{d} - \frac{aq}{d}$
\\

Analogamente, temos: $x^* = x_0\frac{c}{d} + \frac{bq}{d}$

Assim todas as soluções de $ax+by=c$ são da forma:
$x = x_0\frac{c}{d} + \frac{bq}{d}$, $y = y_0\frac{c}{d} - \frac{aq}{d}$ $\square$
\\


%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Problemas Propostos}



%----------------------------------------------------------------------------------------
\subsection{UVA-543}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=484}{543 - Goldbach's Conjecture}\\

\textbf{Resumo:} 
É dado um número inteiro $n$ ($6 \leq n < 10^6$). O problema consiste em verificar se $n$ pode ser escrito como a soma de dois números
primos ímpares. E em caso positivo dizer quais são esses primos.
\\

\textbf{Solução:}
Para resolver esse problema basta rodar o \textbf{Algoritmo} \autoref{crivo_erastotenes} para $N=n$, e fazer uma varredura linear no vetor $isPrime[]$. Se existir um índice $a$ ($6 \leq a \leq n$) tal que $isPrime[a]$ é $true$ e $isPrime[n-a]$ também é $true$, então o problema acima tem solução. 
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Sum of odd primes}
\begin{algorithmic}[1]
\Procedure{$SumOfPrimes(n)$}{}
\State $isPrime[] \gets CrivoErastotenes(n)$
\\
\For {i := 6 to n}
\If {$isPrime[i]$ e $isPrime[n-i]$} 
\State \Return $[i, n-i]$
\EndIf
\EndFor
\\
\State \Return $"No$ $Solution"$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O \textit{Crivo de Erastótenes} consome tempo proporcional a $O(n \log \log n)$, e o laço na linha $4$ consome tempo $O(n)$. Assim a complexidade do algoritmo $SumOfPrimes(n)$ é $O(n \log \log n)$.

%----------------------------------------------------------------------------------------
\subsection{CodeChef-GOC203}
\href{https://www.codechef.com/problems/GOC203}{GOC203 - Fight for Attendence}\\

\textbf{Resumo:}
São dados inteiros $a$, $b$, $c$ ($1 \leq a, b, c \leq 10^6$) e a equação $ax+by=c$. O problema consiste em determinar 
quando tal equação tem solução inteira.
\\

\textbf{Solução:}
Solução é decorrente do \autoref{equacao_diofantina_implicacao}, bastando checar se $MDC(a,b)|c$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Fight for Attendence}
\begin{algorithmic}[1]
\Procedure{$EquationSolution (a, b, c)$}{}
\If {$MDC(a,b)|c$}
\State \Return $true$
\EndIf
\State \Return $false$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O algoritmo tem a mesma complexidade do \textit{Algoritmo de Euclides}, $O(\log{(a+b)})$. 



%----------------------------------------------------------------------------------------
\subsection{UVA-10407}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1348}{10407 - Simple Division} \\

\textbf{Resumo:} 
Tome $P(S) := \{ x \in \mathbb{Z} \mid  \forall a , b \in S , a \equiv b ( mod$ $x)\}$ em que $S \subset \mathbb{Z}$.

O problema consiste em encontrar o valor máximo de $P(S)$ dado um conjunto $S$.
\\

\textbf{Solução:} 
Seja $S = \{S_1, S_2, S_3, ..., S_n\}$, com $n = |S|$, o conjunto dado pelo problema (assumiremos que os valores de S estão ordenados crescentemente).

Tome um número qualquer $d \in P(S)$. Por definição temos que $\forall S_i, S_j \in S$, $S_i \equiv S_j ( mod$ $d) \Rightarrow $ 
$ (S_i-S_j) \equiv 0 ( mod$ $d) \Rightarrow d \mid (S_i-S_j)$ .

Pelo \textbf{Proposição} \autoref{corolario_divisibilidade_1} sabemos que:

$d | (S_i-S_{i-1})$, $ \forall i \in \mathbb{N}, 2 \leq i \leq n \Rightarrow d | (S_i-S_j)$, $ \forall S_i, S_j \in S \Rightarrow d \in P(S)$.

E desse modo, para calcular o valor máximo de $P(S)$ só precisamos calcular o Máximo Divisor Comum das diferenças $(S_i-S_{i-1})$ com $i$ variando de $2$ a $n$ $\square$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Simple Division}\label{euclid}
\begin{algorithmic}[1]
\Procedure{GetMaximumValue (S)}{}
\State $S \gets sort(S)$ \Comment{sort(X) retorna o conjunto X ordenado.} 
\State $maxValue \gets 0$
\For {i := 2 to |S|} 
\State $maxValue \gets MDC(maxValue, S_i - S_{i-1})$
\EndFor
\State \Return{$maxValue$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Pela \textbf{Proposição} \autoref{corolario_divisibilidade_1.1} sabemos que não é preciso o conjunto $S$ ser ordenado.
Assim a complexidade do algoritmo final será $O(|S|\log (\max (S_i-S_{i-1})))$.



%----------------------------------------------------------------------------------------
\subsection{CodeChef-MAANDI}
\href{https://www.codechef.com/problems/MAANDI}{MAANDI - Maxim and Dividers}\\

\textbf{Resumo:}
Calcular quantos divisores de um número inteiro $n$ ($1\leq n \leq 10^9$), contém os dígitos $4$ e $7$ na forma decimal.
Por exemplo, para $n=94$ os únicos divisores que contém tais dígitos são: $47, 94$.
\newline

\textbf{Solução:}
Para esse problema, basta calcular todos os divisores de $n$, com o \textbf{Algoritmo} \autoref{encontra_divisores}, e depois verificar quais deles contêm os dígitos $4$ ou $7$.
\clearpage

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Maxim and Dividers}
\begin{algorithmic}[1]
\Procedure{FindOverluckiDivisors (n)}{}
\State $D \gets FindDivisors(n)$ \Comment{\textbf{Algoritmo} \autoref{encontra_divisores}}
\State $count \gets 0$
\\
\For {\textbf{each } $d \in D$}
\State $hasDigits \gets false$
\\
\While {d > 0}
\State $resto \gets d \bmod 10$
\If {$resto = 4$ || $resto = 7$}
\State $hasDigits \gets true$
\EndIf
\State $d \gets \frac{d}{10}$
\EndWhile
\\
\If {$hasDigits$}
\State $count \gets count + 1$
\EndIf
\EndFor
\\
\State \Return $count$

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
O laço da linha $5$ roda em tempo $O(\sqrt{n})$, já que o número de elementos em $D$ é da ordem de $O(\sqrt{N})$. O número de dígitos de cada divisor $d$ é da ordem de 
$O(\log_{10}d)$, ou melhor $O(\log n)$. Assim o laço da linha $8$ consome tempo proporcional à $O(\log n)$ e a complexidade total do algoritmo é $O(\sqrt n\log n)$. 



%----------------------------------------------------------------------------------------
\subsection{UVA-10090}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1031}{10090 - Marbles}\\


\textbf{Resumo:}
É dado um inteiro $n$ ($1 < n \leq 2*10^9$) que corresponde ao número de bolinhas disponíveis que serão colocadas em caixas. São dados também dois tipos de caixas:
A caixa do tipo $1$ que pode armazenar $n_1$ bolinhas e custa $c_1$; E a caixa do tipo $2$ que pode armazenar $n_2$ bolinhas e custa $c_2$.

O problema consiste em encontrar o custo mínimo para comprar caixas de forma que todas as caixas compradas estejam totalmente
 preenchidas e todas as $n$ bolinhas estejam dentro de alguma caixa.
%É dado um número inteiro $n$ ($0 < n \leq 10^8$). O problema consiste em verificar se $n$ pode, ou não pode, ser escrito como a soma de dois números primos.
%E em caso afirmativo encontrar o valor desses dois primos.
\\

\textbf{Solução:}
Imagine que compramos $x$ caixas do tipo $1$ e $y$ caixas do tipo $2$. Desse modo, o problema se resume em encontrar os valores $x$ e $y$, tal que: 
\newline

$n_1x + n_2y = n$, com $x,y\geq 0$, e que $c_1x+c_2y$ seja mínimo.
\newline 

Como no enunciado do problema é garantido que existe uma solução, então pelo \autoref{equacao_diofantina_implicacao} sabemos que $MDC(n_1,n_2) | n$.

Pelo \textbf{Corolário} \autoref{mdc_extended_solutions} sabemos que toda solução $x$ e $y$ são da forma:

$x=(x_0\frac{n}{d} + \frac{n_2q}{d})$ e $y =(y_0\frac{n}{d} - \frac{n_1q}{d})$, onde $d = MDC(n_1,n_2)$ e $q$ é um inteiro qualquer.

Desse modo temos:
\newline

$x\geq0 \Rightarrow (x_0\frac{n}{d} + \frac{n_2q}{d})\geq 0 \Rightarrow q \geq \lceil -\frac{x_0n}{n_2} \rceil$
\newline

$y\geq0 \Rightarrow (y_0\frac{n}{d} - \frac{n_1q}{d}) \geq 0 \Rightarrow q \leq \lfloor \frac{y_0n}{n_1} \rfloor$
\newline

$\lceil -\frac{x_0n}{n_2} \rceil \leq q \leq \lfloor \frac{y_0n}{n_1} \rfloor$
\newline

Queremos encontrar o valor $min\{c_1x+c_2y\}$, onde $min\{f\}$ é o valor mínimo que a expressão $f$ assume. Portanto:
\newline

$min\{c_1x+c_2y\} = min\big\{c_1(x_0\frac{n}{d} + \frac{n_2q}{d})\big\}$ 
\newline

$min\{c_1x+c_2y\} = min\big\{q(\frac{n_2c_1 - n_1c_2}{d}) + n(\frac{c_1x_0+c_2y_0}{d})\big\}$ 
\newline

$min\{c_1x+c_2y\} = min\big\{q(\frac{n_2c_1 - n_1c_2}{d})\big\} + n(\frac{c_1x_0+c_2y_0}{d})$, já que $n(\frac{c_1x_0+c_2y_0}{d})$ é constante. 
\newline

Se $(\frac{n_2c_1 - n_1c_2}{d})$ for positivo, então $q(\frac{n_2c_1 - n_1c_2}{d})$ assume valor mínimo quando $q$ é mínimo, ie, $q=\lceil -\frac{x_0n}{n_2} \rceil$.

Por outro lado, se $(\frac{n_2c_1 - n_1c_2}{d})$ for negativo, então $q(\frac{n_2c_1 - n_1c_2}{d})$ assume valor mínimo quando $q$ é máximo, ie, $q=\lfloor \frac{y_0n}{n_1} \rfloor$.
\newline

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Marbles}
\begin{algorithmic}[1]
\Procedure{$FindMinimumPrice (n, c_1, n_1, c_2, n_2)$}{}

\State $[d,x_0,y_0] \gets ExtendedMDC(n_1,n_2)$
\\
\If {$(\frac{n_2c_1 - n_1c_2}{d}) \geq 0$}
\State \Return $\lceil -\frac{x_0n}{n_2} \rceil (\frac{n_2c_1 - n_1c_2}{d})$
\\
\Else
\State \Return $\lfloor \frac{y_0n}{n_1} \rfloor (\frac{n_2c_1 - n_1c_2}{d})$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
\newline

\textbf{Análise:}
O único trecho do algoritmo que não roda em tempo constante é a chamada $ExtendedMDC(n_1,n_2)$ na linha $2$, logo a complexidade total do algoritmo é $O(\log(n_1+n_2))$.
\newline




%----------------------------------------------------------------------------------------
\subsection{UVA-718}
\href{https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=659}{718 - Skyscraper Floors}\\

\textbf{Resumo:}
É dado um prédio com $F$ andares (numerados de $0$ até $F-1$) e $E$ elevadores. Cada elevador $i$ tem uma posição inicial $Y_i$ ($Y_i \geq 0$) e uma constante $X_i$ ($X_i > 0$), 
de tal forma que os únicos andares que esse elevador consegue chegar são da forma, $Y_i+X_it$, com $t$ inteiro. 
Cada elevador $i$ não consegue atingir andares menores que $Y_i$ e maiores ou iguais a $F$, ie, $Y_i \leq Y_i+X_it \leq F-1$, ou melhor, $0 \leq t \leq \frac{F-1-Y_i}{X_i}$.
Dado os valores $F$, $E$, e as constantes $Y_i$, $X_i$ para cada elevador, o problema consiste em verificar se é possível ir do andar $A$ até o andar $B$ ($0\leq A,B <F$)
usando os $E$ elevadores.
\\

\textbf{Solução:} 
Primeiro imagine que temos um grafo bidirecionado com $E$ vértices, onde cada vértice representa um elevador e cada aresta $(u,v)$ nos indica que os elevadores $u$ e $v$ 
conseguem chegar em algum andar em comum.
Sabemos quais elevadores atingem o andar $A$, basta verificar se $Y_i+X_it=A$ tem solução $t$ inteira. Analogamente sabemos quais elevadores atingem o andar
$B$. Então só precisaríamos fazer uma busca (\href{https://en.wikipedia.org/wiki/Breadth-first_search}{BFS} ou \href{https://en.wikipedia.org/wiki/Depth-first_search}{DFS})
nesse grafo e verificar se há um caminho de um elevador que atinge o andar $A$ até algum elevador que atinge o andar $B$.

Porém, para esse problema, não entraremos em detalhe nos algoritmos envolvendo grafos. Nos focaremos na parte matemática do problema, que envolve descobrir quando dois elevadores conseguem chegar em algum andar em comum, nos possibilitando assim, construir o grafo e resolver o problema.

Dois elevadores $u$ e $v$ atingem um andar em comum, se existe inteiros $t_u$ ($0\leq t_u\leq \frac{F-1-Y_u}{X_u}$) e $t_v$ ($0\leq t_v\leq \frac{F-1-Y_v}{X_v}$), tal que
$Y_u+X_ut_u = Y_v+X_vt_v$, o que nos dá a \textit{Equação Diofantina Linear} $X_ut_u + (-X_v)tv = (Y_v-Y_u)$.

Vamos mostrar agora um método para calcular $t_u$ e $t_v$, tal que $at_u + bt_v = c$, com $a=X_u$, $b=-X_v$ e c=$(Y_v-Y_u)$.
Pelo \autoref{equacao_diofantina_implicacao}, sabemos que essa equação tem solução, se e somente se, $MDC(a,b)|c$. Observe também que se $Y_u=Y_v$ os elevadores estarão conectados.
Checaremos essas restrições no começo do algoritmo, e daqui para frente assumiremos que $MDC(a,b)|c$ e $Y_u\neq Y_v$.

Tome $d$, $t_1$, $t_2$ como sendo os valores retornados por $ExtendedMDC(a,b)$, temos então pelo \textbf{Corolário} \autoref{mdc_extended_solutions} que todas as soluções da
equação $at_u + bt_v = c$, são da forma $t_u = (t_1\frac{c}{d} + \frac{bq}{d})$ e $t_v = (t_2\frac{c}{d} - \frac{aq}{d})$, com $q \in\mathbb{Z}$. Logo:
\\

$t_u = (t_1\frac{c}{d} + \frac{bq}{d}) \Rightarrow \frac{-t_1c}{b} \leq q \leq \big[(\frac{F-1-Y_u}{X_u})d - t_1c\big]\frac{1}{b}$, já que $0\leq t_u\leq \frac{F-1-Y_u}{X_u}$
\\

Analogamente temos:
\\

$t_v = (t_2\frac{c}{d} - \frac{aq}{d}) \Rightarrow \frac{t_2c}{a} \geq q \geq \big[t_2c - (\frac{F-1-Y_v}{X_v})d\big]\frac{1}{a}$, já que $0\leq t_u\leq \frac{F-1-Y_u}{X_u}$
\\

Das duas inequações acima, temos:
\\

$max\Big(\frac{-t_1c}{b}, \big[t_2c - (\frac{F-1-Y_v}{X_v})d\big]\frac{1}{a} \Big) \leq q \leq min\Big(\frac{t_2c}{a}, \big[(\frac{F-1-Y_u}{X_u})d - t_1c\big]\frac{1}{b}  \Big)$
\\

Portanto, se a inequação acima tiver solução inteira $q$, os elevadores $u$ e $v$ serão conectados pelo andar $Y_u+X_ut_u = Y_u+X_u\big[(t_1 + \frac{bq}{d})\frac{c}{d}\big]$.
\clearpage

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Verifica se os elevadores $u$ e $v$ estão conexos.}\label{euclid}
\begin{algorithmic}[1]
\Procedure{$ElevatorsConected (X_u, Y_u, X_v, Y_y, F)$}{}
\State $a \gets X_u$
\State $b \gets -X_v$
\State $c \gets Y_v-Y_u$
\State $[d,t_1,t_2] \gets ExtendedMDC(a,b)$
\\
\If {$Y_u = Y_v$} %\Comment{Se $Y_u=Y_v$ então os elevadores estão conexos}
\State \Return {$true$}
\EndIf
\\
\If {$d \nmid c$}
\State \Return {$false$}
\EndIf
\\
\Comment{A partir desse ponto temos: $c\neq0$ e $d|c$}
\\
\State {$letf \gets max\Big(\frac{-t_1c}{b}, \big[t_2c - (\frac{F-1-Y_v}{X_v})d\big]\frac{1}{a} \Big)$}% max\Big(\frac{-t_1d}{b}, \big[t_2 - (\frac{F-1-Y_v}{X_v})\frac{d}{c}\big]\frac{d}{a}  \Big)$}
\State {$right \gets min\Big(\frac{t_2c}{a}, \big[(\frac{F-1-Y_u}{X_u})d - t_1c\big]\frac{1}{b}  \Big) $}%min\Big(\frac{t_2d}{a}, \big[(\frac{F-1-Y_u}{X_u})\frac{d}{c} - t_1\big] \frac{d}{b} \Big)$}
\\
\If {$\lceil left \rceil \leq \lfloor right \rfloor$}
\State \Return {$true$}
\EndIf
\\
\State \Return {$false$}

\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O único trecho do algoritmo que não roda em tempo constante é a chamada $ExtendedMDC(a,b)$ na linha $5$, logo a complexidade total do algoritmo é $O(\log(a+b)) = O(\log(X_u+X_v))$.
