% Chapter 1

\chapter{Divisibilidade} % Main chapter title

\label{Chapter1} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introdução}
A noção de divisibilidade dos números inteiros é fundamental na \textbf{Teoria dos Números}.
Nesse seção vamos descrever algumas definições e propriedades que serão utilizados ao longo desse trabalho.

\begin{definition}
A notação $d|n$ ("$d$ \textbf{divive} $n$"), significa que existe um inteiro $q$, tal que, $n = dq$.
Se $d|n$ dizemos que $n$ é múltiplo de $d$. Caso $n$ não seja múltiplo de $d$ (ou seja, $d$ não divide $n$), escrevemos $d \nmid n$.
\end{definition}


\begin{corollary}\label{divisibilidade_transitiva}
$d|n$ , $d|m \Rightarrow d|(n+m)$
\end{corollary}
\textbf{Demonstração:}
Se $d|n$ e $d|m$, então existe inteiros $q$ e $k$, tal que, $n = qd$ e $m = kd$. Desse modo temos:

$(n+m) = qd + kd = (q + k)d \Rightarrow d|(n+m) $ $\square$


\begin{corollary}\label{divisibilidade_fracao}
$d|(\frac{n}{m}) \Rightarrow dm|n$
\end{corollary}
\textbf{Demonstração:}

$d|(\frac{n}{m}) \Rightarrow \exists q \in \mathbb{Z} \mid \frac{n}{m} = qd$

$d|(\frac{n}{m}) \Rightarrow n = q(dm) \Rightarrow dm|n$ $\square$


\begin{corollary}\label{corolario_divisibilidade_1}
Dado um subconjunto dos inteiros $S = \{S_1, S_2, S_3, ..., S_n\}$ ordenado crescentemente, e um número inteiro $d$, tal que, $d|(S_i-S_{i-1})$, $2 \leq i \leq n$, 
temos que: 

$d|(S_i-S_j)$, $\forall S_i, S_j \in S$.

\end{corollary}
\textbf{Demonstração:}
Tome $S_i,S_j \in S$ quaisquer, e sem perda de generalidade assuma que $S_i \geq S_j$ (ie, $i \geq j$, pois $S$ está ordenado crescentemente).

Como $i \geq j$, tome $r \in \mathbb{N}$ como sendo a diferença entre $i$ e $j$ : $i = j + r$.

Vamos agora provar por indução que $d|(S_{j+r}-S_j)$.

Para $r=0$ ou $r=1$ a demostração segue trivialmente.

Assuma que o corolário funciona para $(r-1)$, ie, $d|(S_{j+r-1}-S_j)$. 

Temos então que: 

$d|(S_{j+r}-S_{j+r-1}) \Rightarrow d|(S_{j+r}-S_{j+r-1})+(S_{j+r-1}-S_j)$ ($\triangleright$ \textbf{Corolário} \autoref{divisibilidade_transitiva})

$d|(S_{j+r}-S_{j+r-1}) \Rightarrow d|(S_{j+r}-S_j)$ $\square$ 


\begin{corollary}
O \textbf{Corolário} \autoref{corolario_divisibilidade_1} funciona mesmo se o conjunto $S$ não estiver ordenado.
\end{corollary}
\textbf{Demonstração:}
Deixaremos a demostração a cargo do leitor.


\begin{theorem}[Teorema da Divisão]\label{algoritmo_divisao}
Para todo número inteiro $a$ e qualquer número inteiro positivo $n$, existe inteiros únicos $q$ e $r$, tal que:

$a = qn + r$, $0 \leq r < n$

O valor $q$ ($q = \lfloor  \frac{a}{n} \rfloor$) é chamado de \textbf{quociente} da divisão, e o valor $r$ ($r = a \bmod n$) é chamado de \textbf{resto}
(ou \textbf{resíduo}) da divisão.
\end{theorem}
\textbf{Demonstração:}
Suponha que $q$ e $r$ não sejam únicos, ie, que exista $q^*$ e $r^*$ tal que: $a = q^*n + r^*, 0 \leq r^* < n$.

$a = qn + r = q^*n + r^* \Rightarrow (r - r^*) = (q^* - q)n \Rightarrow (r - r^*) \equiv (q^* - q)n \equiv 0 (mod$ $n)$

Porém, como $r \neq r^*$, e tanto $r$ quanto $r^*$ são menores que $n$, temos que: 

$r \not\equiv r^* (mod$ $n) \Rightarrow (r - r^*) \not\equiv 0 (mod$ $n)$

Chegando numa contradição, e assim $q$ e $r$ são únicos $\square$ \\

\begin{corollary}\label{divisibilidade_modular}
$d|n$ , $d|m \Rightarrow d|(n \bmod m)$
\end{corollary}
\textbf{Demonstração:}

$d|n \Rightarrow n = k_1d, k_1 \in \mathbb{Z}$

$d|m \Rightarrow m = k_2d, k_2 \in \mathbb{Z}$

$n = qm + (n \bmod m) \Rightarrow (n \bmod m) = n - qm$ ($\triangleright$ \autoref{algoritmo_divisao})

$(n \bmod m) = k_1d - qk_2d = (k_1 - qk_2)d \Rightarrow d|(n \bmod m)$ $\square$


\begin{corollary}\label{divisibilidade_modular2}
$d|m$ , $d|(n \bmod m) \Rightarrow d|n$
\end{corollary}
\textbf{Demonstração:}

$d|m \Rightarrow m = k_1d, k_1 \in \mathbb{Z}$

$d|(n \bmod m) \Rightarrow (n \bmod m) = k_2d, k_2 \in \mathbb{Z}$

$n = qm + (n \bmod m) \Rightarrow n = qk_1d + k_2d$ ($\triangleright$ \autoref{algoritmo_divisao})

$n = (qk_1 + k_2)d \Rightarrow d|n$ $\square$


\subsection{Divisores}
Nessa subsessão mostraremos um algoritmo simples para calcular todos os divisores de um determinado número inteiro positivo qualquer.

\begin{theorem} 
O número de divisores de $n \in \mathbb{Z}^{+}$ é da ordem de $O(\sqrt{n})$.
\end{theorem}
\textbf{Demonstração:}
Tome um divisor $d$ de $n$ qualquer, com $d > \sqrt{n}$. Dessa forma sabemos que existe um inteiro $q$, com $n=qd$ (observe que $q$ também é divisor de $n$). 
Como $d > \sqrt{n}$ então $q < \sqrt{n}$. Assim, para qualquer divisor $d$ de $n$ maior que $\sqrt{n}$, existe exatamente um divisor $q$ de $n$ menor que $\sqrt{n}$ correspondente ao mesmo.
O que implica que só existe no máximo $\sqrt{n}$ divisores maiores que $\sqrt{n}$. Por outro lado, claramente só existem $\sqrt{n}$ divisores menores que $\sqrt{n}$.
Concluímos então que o número total de divisores de $n$ é da ordem de $O(\sqrt{n})$. $\square$
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Encontra todos os divisores de N}\label{encontra_divisores}
\begin{algorithmic}[1]
\Procedure{FindDivisors (N)}{}
\State $D \gets \emptyset$ \Comment{Conjunto $D$ contém os divisores de $N$}

\For {($d = 1 \text{; } d^2 \leq N \text{; } d++)$}

\If {$d\nmid N$}
\State \textbf{continue}
\EndIf
\State $D \gets D \cup \{d\}$
\State $q \gets \frac{N}{d}$
\If {$q\neq d$}
\State $D \gets D \cup \{q\}$
\EndIf

\EndFor

\State \Return{$D$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O laço da linha 3 consome tempo  $O(\sqrt{N})$, testando se os números menores que $\sqrt{N}$ são divisores. Na linha 7 são calculados os divisores correspondentes maiores 
que $\sqrt{N}$. E a condição da linha 8 garante que se $N$ for quadrado perfeito, então é inserido $\sqrt{N}$ somente uma vez no conjunto $D$.
Assim a complexidade total do algoritmo é $O(\sqrt{N})$.




%-----------------------------------
%	SECTION 2
%-----------------------------------
\section{Números Primos}

\begin{definition} 
Todo número inteiro n (n > 1) que têm apenas dois divisores distintos (1 e n) é chamado de número primo. Se n (n > 1) não for primo, dizemos que n é número composto.
\end{definition}


\begin{theorem}[Fatoração Única]\label{fatoracao_unica}
Um número natural qualquer $n$, pode ser escrito unicamente como um produto da forma: 
$n = p_1^{a_1}p_2^{a_2}...p_k^{a_k}$, onde os $p_i$ são números primos, $p_1 < p_2 < ... < p_k$, e os números $a_i$ são inteiros positivos.
\end{theorem}
\textbf{Demonstração:}
Deixaremos a demostração a cargo do leitor.
\textbf{Dica:} Use o fato de que o conjunto dos primos que divide um número inteiro é único, e fato de que se qualquer potência $a_i$ for alterado o valor de $n$ será alterado.



%-----------------------------------
%	SECTION 3
%-----------------------------------
\section{Máximo Divisor Comum}

\begin{definition}
O Máximo Divisor Comum de dois inteiros quaisquer $a$ e $b$ (com a ou b diferente de zero), denotado por $MDC(a,b)$, é o maior inteiro que divide ambos $a$ e $b$. 
Se $MDC(a,b) = 1$ dizemos que $a$ e $b$ são primos entre si.
\end{definition}


\begin{corollary}\label{gcd_modular}
Para números inteiros quaisquer $a$ e $b$, $MDC(a,b) = MDC(b, a \bmod b)$
\end{corollary}
\textbf{Demonstração:}
Pelo \textbf{Corolário} \autoref{divisibilidade_modular} e \autoref{divisibilidade_modular2}, temos:

$d|a, d|b \Leftrightarrow d|b, d|(a \bmod b)$

Assim, qualquer divisor de $a$ e $b$ é também divisor de $b$ e $(a \bmod b)$ (e vise versa). Implicando que o \textbf{Máximo Divisor Comum} de $a$ e $b$
é igual ao \textbf{Máximo Divisor Comum} de $b$ e $(a \bmod b)$. $\square$



\begin{corollary}\label{divisibilidade_mdc}
$MDC(a,b) = d \Rightarrow MDC(\frac{a}{d}, \frac{b}{d}) = 1$
\end{corollary}
\textbf{Demonstração:}
Suponha que $MDC(\frac{a}{d}, \frac{b}{d}) = r > 1$. Assim temos:

$r|\frac{a}{d} \Rightarrow dr|a$ ($\triangleright$ \textbf{Corolário} \autoref{divisibilidade_fracao})

$r|\frac{b}{d} \Rightarrow dr|b$ ($\triangleright$ \textbf{Corolário} \autoref{divisibilidade_fracao})

$r > 1 \Rightarrow dr > d \Rightarrow dr > MDC(a,b)$

Chegamos então numa contradição, pois $dr$ é divisor comum de $a$ e $b$, e $dr$ é maior que o \textbf{Máximo Divisor Comum} de $a$ e $b$. $\square$



\begin{corollary}\label{corolario_gcd_soma}
Para números inteiros quaisquer $a$ e $b$, $MDC(a,b) = MDC(a,a \pm b)$
\end{corollary}
\textbf{Demonstração:}
A prova dessa expressão vem do fato de que qualder divisor de $a$ e $b$, é também divisor de $(a \pm b)$.



\begin{corollary}\label{corolario_gcd_produto}
Para números inteiros quaisquer $a$ e $b$, temos:

$MDC(a,b) = 1 \Rightarrow MDC(a,bk) = MDC(a,k)$, com $k \in \mathbb{Z}$
\end{corollary}
\textbf{Demonstração:}
A prova dessa expressão vem do fato de que qualder divisor $d$ de $a$ e $bk$, é também divisor de $k$, pois $d$ não divide $b$ ($MDC(a,b) = 1$).




\subsection{Algoritmo de Euclides}
A ideia principal do \textbf{Algoritmo de Euclides} é calcular recursivamente o \textbf{Máximo Divisor Comum} de dois números baseando-se no 
\textbf{Corolário} \autoref{gcd_modular}.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Algoritmo de Euclides}\label{mdc}
\begin{algorithmic}[1]
\Procedure{$MDC (a, b)$}{}
\If {$a = 0$}
\State \Return $b$
\EndIf
\State \Return $MDC(b \bmod a, a)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
TODO



\subsection{Teorema de Bézout}

\begin{corollary}\label{bezout_conjunto_nao_nulo}
Dado o conjunto de combinações lineares positivas $S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$, onde os números $a$ e $b$ são inteiros, 
e pelo menos um desses números é diferente de zero. Temos então que $S \neq \emptyset$. 
\end{corollary}
\textbf{Demonstração:}
As combinações possíveis para $a$ e $b$ são:

$a > 0 \Rightarrow |a| = 1.a + 0.b$

$a < 0 \Rightarrow |a| = (-1).a + 0.b$

$b > 0 \Rightarrow |b| = 0.a + 1.b$

$b < 0 \Rightarrow |b| = 0.a + (-1).b$

Como não temos ambos $a$ e $b$ iguais à zero, então $S$ deve conter pelo menos $|a|$ ou $|b|$, e assim $S \neq \emptyset$ $\square$


\begin{corollary}\label{bezout_conjunto_divide}
Dado o conjunto de combinações lineares positivas $S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$, onde os números $a$ e $b$ são inteiros, 
e pelo menos um desses números é diferente de zero. Temos então que o menor número $d \in S$ divide todos elementos de $S$.
\end{corollary}
\textbf{Demonstração:}
Como $d \in S$, $\exists m,n\in\mathbb{Z} \mid d = ma + nb$.

Tome $x \in S$ qualquer. Pelo \autoref{algoritmo_divisao} $x = qd + r$, $0 \leq r < d$.

Suponha que $d\nmid x$, ie, $x \neq qd$ e $0 < r$. Como $x \in S$, $\exists m^*,n^*\in\mathbb{Z} \mid x = m^*a + n^*b$, e assim:

$x = m^*a + n^*b, x = qd + r \Rightarrow r = m^*a + n^*b - qd = m^*a + n^*b - q(ma + nb)$ 

$\Rightarrow r = (m^* - qm)a + (n^* - qn)b \Rightarrow r \in S$, pois $r > 0$

Chegando numa contrdição, pois $r \in S$, $d \in S$, $r < d$ e $d$ é o menor elemento em $S$.

Desse modo, temos que $d$ divide todos os elementos de $S$. $\square$


\begin{theorem}[Teorema de Bézout]\label{teorema_bezout}
$\forall$ $a$, $b \in \mathbb{Z}$ (com pelo menos um dos dois números diferente de zero), $\exists$ $x, y \in \mathbb{Z} \mid ax + by = mdc(a, b).$
\end{theorem}
\textbf{Demonstração:}
Tome o conjunto das combinações lineares de $a$ e $b$:

$S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$.

Pelo \textbf{Corolário} \autoref{bezout_conjunto_nao_nulo} sabemos que $S \neq \emptyset$. Como $S$ contém somente números positivos e não é vazio, 
$S$ está limitado inferiormente por \textit{zero} e assim, $S$ tem um elemento mínimo que chamaremos de $d$.

Como $d \in S$, então existe $u, v\in \mathbb{Z}$, tal que, $d = ua + vb$. Pelo \textbf{Corolário} \autoref{bezout_conjunto_divide}, sabemos que $d$ divide todos elementos em $S$, em particular:

$d$ divide $|a|$ e $|b| \Rightarrow d|MDC(a,b) \Rightarrow 0 < d \leq MDC(a,b)$

Por outro lado, $MDC(a,b)$ também divide $a$ e $b$:

$MDC(a,b)|a$ e $MDC(a,b)|b \Rightarrow MDC(a,b)|(ua + vb)$

$ \Rightarrow MDC(a,b)|d \Rightarrow MDC(a,b) \leq d$

$MDC(a,b)\leq d$ e $d \leq MDC(a,b) \Rightarrow MDC(a,b) = d \Rightarrow MDC(a,b) \in S$ $\square$





%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Crivo de Erastóteles}

O \textit{Crivo de Erastótenes} é um algoritmo criado pelo matemático \textbf{Erastótenes} (a.C. 285-194 a.C.) para o cálculo de números primos
até um certo valor limite $N$.
O algoritmo mantém uma tabela com $N$ elementos, e para cada primo, começando pelo número $2$, marca na tabelo os números compostos múltiplos desses primos.
Desse modo, ao final do algoritmo, os elementos não marcados são números primos.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Crivo de Erastótenes paro o cálculo de números primos}\label{crivo_erastotenes}
\begin{algorithmic}[1]
\Procedure{CrivoErastótenes (N)}{}
\State $isPrime[] \gets \text{new Array}[N]$ \Comment{$isPrime[]$ é um vetor booleano}

\For {($p = 2 \text{; } p \leq N \text{; } p++)$}
\State $isPrime[p] \gets true$
\EndFor

\For {($p = 2 \text{; } p^2 \leq N \text{; } p++)$}
\If {$isPrime[p] = false$}
\State \textbf{continue}
\EndIf
\For {($n = p^2 \text{; } n \leq N \text{; } n = n+p)$}
\State $isPrime[n] \gets false$
\EndFor
\EndFor

\State \Return{$isPrime[]$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
TODO


%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Equações Diofantinas}

\textit{Equações Diofantinas} são equações polinomiais com variáveis inteiras. Alguns exemplos são mostrados a seguir, sendo $x$, $y$, $z$ incógnitas, e $a$, $b$, $n$ constantes inteiras:

$ax + by = n$ ($\triangleright$ \textit{Equação Diofantina Linear})

$ax + by = MDC(a,b)$ ($\triangleright$ \textit{Identidade de Bézout})

$x^n + y^n = z^n$ ($\triangleright$ Equação base do \textit{Último Teorema de Fermat})

$x^2 - ny^2 = \pm 1$ ($\triangleright$ \textit{Equação de Pell})\\



Nesse trabalho abordaremos somente \textit{Equações Diofantinas Lineares}, da forma:

$\sum_{i=1}^{k}a_i x_i = c$

onde $c$ e $a_i$ são constantes, e $x_i$ variáveis inteiras.\\


\begin{theorem}\label{equacao_diofantina_implicacao}
Dados inteiros $a$, $b$, $c$ , temos que:

$MDC(a,b)|c \Leftrightarrow$ a \textit{Equação Diofantina} $ax + by=c$, tem solução inteira.
\end{theorem}
\textbf{Demonstração:}
Provaremos primeiro a ida da implicação.

Pelo \autoref{teorema_bezout} sabemos que existe $x^*$ e $y^*$, tal que, $ax^* + by^* = MDC(a,b)$. Logo:

$MDC(a,b)|c \Rightarrow \exists! q\in\mathbb{Z} \mid c = MDC(a,b)q \Rightarrow a(x^*q) + b(y^*q) = MDC(a,b)q = c$ $\square$

Provaremos agora a volta da implicação.

Sabemos que existe inteiros $u$ e $v$, tal que, $a=MDC(a,b)u$ e $b=MDC(a,b)v$. Logo:

$ax + by=c$, tem solução inteira $\Rightarrow MDC(a,b)ux + MDC(a,b)vy = c$

$\Rightarrow MDC(a,b)(ux + vy) = c \Rightarrow MDC(a,b)|c$. $\square$ 

%----------------------------------------------------------------------------------------

\subsection{Algoritmo de Euclides Extendido}

\textit{Algoritmo de Euclides Extendido} é uma extensão do \textit{Algoritmo de Euclides} que calcula não só o $MDC(a,b)$, para dados $a$ e $b$, mas também encontra
uma solução para a \textit{Identidade de Bézout} $ax+by = MDC(a,b)$. 


\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Algoritmo de Euclides Extendido}\label{mdc_extended}
\begin{algorithmic}[1]
\Procedure{$ExtendedMDC (a, b)$}{}
\If {$a = 0$}
\State \Return $[b,0,1]$
\EndIf
\\
\State $[d,x,y] \gets Extended(b \bmod a, a)$
\State $x^* \gets y - \lfloor \frac{b}{a} \rfloor x$
\State $y^* \gets x$
\State \Return $[d,x^*,y^*]$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Em vez de retornar um inteiro, $ExtendedMDC(a,b)$ retorna uma tupla $[d,x,y]$, onde $d=MDC(a,b)$ e $x$,$y$ são a solução da equação $ax+by=d=MDC(a,b)$.
Sabemos que $[d,x,y]$ na linha $5$ satisfaz a equação, $(b\bmod a)x + ay = d$, assim:

$(b\bmod a)x + ay = d \Rightarrow (b - \lfloor \frac{b}{a} \rfloor a)x + ay = d$

$\Rightarrow a(y-\lfloor \frac{b}{a} \rfloor x) + b(x) = ax^* + by^* = d = MDC(a,b)$

Observe que o \textit{Algoritmo de Euclides Extendido} é baseado no \textit{Algoritmo de Euclides}, tendo a mesma complexidade $O(\log(a+b))$.





%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Problemas Propostos}


%----------------------------------------------------------------------------------------
\subsection{CodeChef-GOC203}
\href{https://www.codechef.com/problems/GOC203}{GOC203 - Fight for Attendence}\\

\textbf{Resumo:}
São dados inteiros $a$, $b$, $c$ ($1 \leq a, b, c \leq 10^6$) e a equação $ax+by=c$. O problema consiste em determinar 
quando tal equação tem solução inteira.
\\

\textbf{Solução:}
Solução é decorrente do \autoref{equacao_diofantina_implicacao}, bastando checar se $MDC(a,b)|c$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Fight for Attendence}
\begin{algorithmic}[1]
\Procedure{$EquationSolution (a, b, c)$}{}
\If {$MDC(a,b)|c$}
\State \Return $true$
\EndIf
\State \Return $false$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O algoritmo tem a mesma complexidado do \textit{Algoritmo de Euclides}, $O(\log{(a+b)})$. 



%----------------------------------------------------------------------------------------
\subsection{UVA-10407}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1348}{10407 - Simple Division} \\

\textbf{Resumo:} 
Tome $P(S) := \{ x \in \mathbb{Z} \mid  \forall a , b \in S , a \equiv b ( mod$ $x)\}$ em que $S \subset \mathbb{Z}$.

O problema consiste em encontrar o valor máximo de $P(S)$ dado um conjunto $S$.
\\

\textbf{Solução:} 
Seja $S = \{S_1, S_2, S_3, ..., S_n\}$, com $n = |S|$, o conjunto dado pelo problema (assumiremos que os valores de S estão ordenados crescentemente).

Tome um número qualquer $d \in P(S)$. Por definição temos que $\forall S_i, S_j \in S$, $S_i \equiv S_j ( mod$ $d) \Rightarrow $ 
$ (S_i-S_j) \equiv 0 ( mod$ $d) \Rightarrow d \mid (S_i-S_j)$ .

Pelo \textbf{Corolário} \autoref{corolario_divisibilidade_1} sabemos que:

$d | (S_i-S_{i-1})$, $ \forall i \in \mathbb{N}, 2 \leq i \leq n \Rightarrow d | (S_i-S_j)$, $ \forall S_i, S_j \in S \Rightarrow d \in P(S)$.

E desse modo, para calcular o valor máximo de $P(S)$ só precisamos calcular o Máximo Divisor Comum das diferenças $(S_i-S_{i-1})$ com $i$ variando de $2$ à $n$ $\square$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Simple Division}\label{euclid}
\begin{algorithmic}[1]
\Procedure{GetMaximumValue (S)}{}
\State $S \gets sort(S)$ \Comment{sort(X) retorna o conjunto X ordenado.} 
\State $maxValue \gets 0$
\For {i := 2 to |S|} 
\State $maxValue \gets MDC(maxValue, S_i - S_{i-1})$
\EndFor
\State \Return{$maxValue$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}



%----------------------------------------------------------------------------------------
\subsection{CodeChef-MAANDI}
\href{https://www.codechef.com/problems/MAANDI}{MAANDI - Maxim and Dividers}\\

\textbf{Resumo:}
Calcular quantos divisores de um número inteiro $n$ ($1\leq n \leq 10^9$), contém os dígitos $4$ e $7$ na forma decimal.
Por exemplo, para $n=94$ os únicos divisore que contém tais dígitos são: $47, 94$.

\textbf{Solução:}
Para esse problema, basta calcular todos os divisores de $n$, com o \textbf{Algoritmo} \autoref{encontra_divisores}, e depois verificar quais deles contêm os digitos $4$ ou $7$.

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Maxim and Dividers}
\begin{algorithmic}[1]
\Procedure{FindOverluckiDivisors (n)}{}
\State $D \gets FindDivisors(n)$ \Comment{\textbf{Algoritmo} \autoref{encontra_divisores}}
\State $count \gets 0$
\\
\For {\textbf{each } $d \in D$}
\State $hasDigits \gets false$
\\
\While {d > 0}
\State $resto \gets d \bmod 10$
\If {$resto = 4$ || $resto = 7$}
\State $hasDigits \gets true$
\EndIf
\State $d \gets \frac{d}{10}$
\EndWhile
\\
\If {$hasDigits$}
\State $count \gets count + 1$
\EndIf
\EndFor
\\
\State \Return $count$

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
O laço da linha $5$ roda em tempo $O(\sqrt{n})$, já que o número de elementos em $D$ é da ordem de $O(\sqrt{N})$. O número de dígitos de cada divisor $d$ é da ordem de 
$O(\log_{10}d)$, ou melhor $O(\log n)$. Assim o laço da linha $8$ consome tempo proporcional à $O(\log n)$ e a complexidade total do algoritmo é $O(\sqrt n\log n)$. 




%----------------------------------------------------------------------------------------
\subsection{UVA-718}
\href{https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=659}{718 - Skyscraper Floors}\\

\textbf{Resumo:}
É dado um prédio com $F$ andares (numerados de $0$ até $F-1$) e $E$ elevadores. Cada elevador $i$ tem um posição inicial $Y_i$ ($Y_i \geq 0$) e uma constante $X_i$ ($X_i > 0$), 
de tal forma que os únicos andares que esse elevador consegue chegar são da forma, $Y_i+X_it$, com $t$ inteiro. 
Cada elevador $i$ não consegue atingir andares menores que $Y_i$ e maiores ou iguais à $F$, ie, $Y_i \leq Y_i+X_it \leq F-1$, ou melhor, $0 \leq t \leq \frac{F-1-Y_i}{X_i}$.
Dado os valores $F$, $E$, e as constantes $Y_i$, $X_i$ para cada elevador, o problema consite em verificar se é possível ir do andar $A$ até o andar $B$ ($0\leq A,B <F$)
usando os $E$ elevadores.
\\

\textbf{Solução:} 
Primeiro imagine que temos um grafo bidirecionado com $E$ vértices, onde cada vértice representa um elevador e cada aresta $(u,v)$ nos diz que os elevadores $u$ e $v$ 
conseguem chegar em algum andar em comum.
Sabemos quais elevadores atingem o andar $A$, basta verificar se $Y_i+X_it=A$ tem solução $t$ inteira. Analogamente sabemos quais elevadores atingem o andar
$B$. Então só precisaríamos fazer uma busca (\href{https://en.wikipedia.org/wiki/Breadth-first_search}{BFS} ou \href{https://en.wikipedia.org/wiki/Depth-first_search}{DFS})
nesse grafo e verificar se há um caminho de um elevador que atinge o andar $A$ até algum elevador que atinge o andar $B$.

Porém, para esse problema, não entraremos em detalhe nos algoritmos envolvendo grafos. Nos focaremos na parte matemática do problema, que envolve descobrir quando dois elevadores conseguem chegar em algum andar em comum, nos possibilitando assim, construir o grafo e resolver o problema.

Dois elevadores $u$ e $v$ tem um andar em comum, se exite inteiros $t_u$ ($0\leq t_u\leq \frac{F-1-Y_u}{X_u}$) e $t_v$ ($0\leq t_v\leq \frac{F-1-Y_v}{X_v}$), tal que
$Y_u+X_ut_u = Y_v+X_vt_v$, o que nos dá a \textit{Equação Diofantina Linear} $X_ut_u + (-X_v)tv = (Y_v-Y_u)$.

Vamos mostrar agora um método para calcular $t_u$ e $t_v$, tal que $at_u + bt_v = c$, com $a=X_u$, $b=-X_v$ e c=$(Y_v-Y_u)$.
Pelo \autoref{equacao_diofantina_implicacao}, sabemos que essa equação tem solução, se e somente se, $MDC(a,b)|c$. Observe também que se $Y_u=Y_v$ os elevadores estarão
conexos pelo andar $Y_u$.

Tome $d$, $t_1$, $t_2$ como sendo os valores retornados por $ExtendedMDC(a,b)$, temos então pelo \textbf{Corolário} TODO\autoref{TODO} que todas as soluções da
equação $at_u + bt_v = c$, são da forma $t_u = (t_1 + \frac{bq}{d})\frac{c}{d}$ e $t_v = (t_2 - \frac{aq}{d})\frac{c}{d}$, com $q \in\mathbb{Z}$. Logo:
\\

$t_u = (t_1 + \frac{bq}{d})\frac{c}{d} \Rightarrow \frac{-t_1d}{b} \leq q \leq \big[(\frac{F-1-Y_u}{X_u})\frac{d}{c} - t_1\big]\frac{d}{b}$, já que $0\leq t_u\leq \frac{F-1-Y_u}{X_u}$
\\

Analogamente temos:
\\

$t_v = (t_2 - \frac{aq}{d})\frac{c}{d} \Rightarrow \frac{t_2d}{a} \geq q \geq \big[t_2 - (\frac{F-1-Y_v}{X_v})\frac{d}{c}\big]\frac{d}{a}$, já que $0\leq t_u\leq \frac{F-1-Y_u}{X_u}$
\\

Das duas inequações acima, temos:
\\

$max\Big(\frac{-t_1d}{b}, \big[t_2 - (\frac{F-1-Y_v}{X_v})\frac{d}{c}\big]\frac{d}{a}  \Big) \leq q \leq min\Big(\frac{t_2d}{a}, \big[(\frac{F-1-Y_u}{X_u})\frac{d}{c} - t_1\big]\frac{d}{b} \Big)$
\\

Portanto, se a inequação acima tiver solução inteira $q$, os elevadores $u$ e $v$ serão conectados pelo andar $Y_u+X_ut_u = Y_u+X_u\big[(t_1 + \frac{bq}{d})\frac{c}{d}\big]$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Verifica se os elevadores $u$ e $v$ estão conexos.}\label{euclid}
\begin{algorithmic}[1]
\Procedure{$ElevatorsConected (X_u, Y_u, X_v, Y_y, F)$}{}
\State $a \gets X_u$
\State $b \gets -X_v$
\State $c \gets Y_v-Y_u$
\State $[d,t_1,t_2] \gets ExtendedMDC(a,b)$
\\
\If {$Y_u = Y_v$} %\Comment{Se $Y_u=Y_v$ então os elevadores estão conexos}
\State \Return {$true$}
\EndIf
\\
\If {$d \nmid c$}
\State \Return {$false$}
\EndIf
\\
\Comment{A partir desse ponto temos: $c\neq0$ e $d|c$}
\\
\State {$letf \gets max\Big(\frac{-t_1d}{b}, \big[t_2 - (\frac{F-1-Y_v}{X_v})\frac{d}{c}\big]\frac{d}{a}  \Big)$}
\State {$right \gets min\Big(\frac{t_2d}{a}, \big[(\frac{F-1-Y_u}{X_u})\frac{d}{c} - t_1\big] \frac{d}{b} \Big)$}
\\
\If {$\lceil left \rceil \leq \lfloor right \rfloor$}
\State \Return {$true$}
\EndIf
\\
\State \Return {$false$}

\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
O único trecho do algoritmo que não roda em tempo constante é a chamada $ExtendedMDC(a,b)$ na linha $5$, logo a complexidade total do algoritmo é $O(\log(a+b)) = O(\log|X_u=X_v|)$.
