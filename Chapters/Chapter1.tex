% Chapter 1

\chapter{Divisibilidade} % Main chapter title

\label{Chapter1} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introdução}
A noção de divisibilidade dos números inteiros é fundamental na \textbf{Teoria dos Números}.
Nesse seção vamos descrever algumas definições e propriedades que serão utilizados ao longo desse trabalho.

\begin{definition}
A notação $d|n$ ("$d$ \textbf{divive} $n$"), significa que existe um inteiro $q$, tal que, $n = dq$.
Se $d|n$ dizemos que $n$ é múltiplo de $d$. Caso $n$ não seja múltiplo de $d$ (ou seja, $d$ não divide $n$), escrevemos $d \nmid n$.
\end{definition}


\begin{corollary}\label{divisibilidade_transitiva}
$d|n$ , $d|m \Rightarrow d|(n+m)$
\end{corollary}
\textbf{Demonstração:}
Se $d|n$ e $d|m$, então existe inteiros $q$ e $k$, tal que, $n = qd$ e $m = kd$. Desse modo temos:

$(n+m) = qd + kd = (q + k)d \Rightarrow d|(n+m) $ $\square$


\begin{corollary}\label{divisibilidade_fracao}
$d|(\frac{n}{m}) \Rightarrow dm|n$
\end{corollary}
\textbf{Demonstração:}

$d|(\frac{n}{m}) \Rightarrow \exists q \in \mathbb{Z} \mid \frac{n}{m} = qd$

$d|(\frac{n}{m}) \Rightarrow n = q(dm) \Rightarrow dm|n$ $\square$


\begin{corollary}\label{corolario_divisibilidade_1}
Dado um subconjunto dos inteiros $S = \{S_1, S_2, S_3, ..., S_n\}$ ordenado crescentemente, e um número inteiro $d$, tal que, $d|(S_i-S_{i-1})$, $2 \leq i \leq n$, 
temos que: 

$d|(S_i-S_j)$, $\forall S_i, S_j \in S$.

\end{corollary}
\textbf{Demonstração:}
Tome $S_i,S_j \in S$ quaisquer, e sem perda de generalidade assuma que $S_i \geq S_j$ (ie, $i \geq j$, pois $S$ está ordenado crescentemente).

Como $i \geq j$, tome $r \in \mathbb{N}$ como sendo a diferença entre $i$ e $j$ : $i = j + r$.

Vamos agora provar por indução que $d|(S_{j+r}-S_j)$.

Para $r=0$ ou $r=1$ a demostração segue trivialmente.

Assuma que o corolário funciona para $(r-1)$, ie, $d|(S_{j+r-1}-S_j)$. 

Temos então que: 

$d|(S_{j+r}-S_{j+r-1}) \Rightarrow d|(S_{j+r}-S_{j+r-1})+(S_{j+r-1}-S_j)$ ($\triangleright$ \textbf{Corolário} \autoref{divisibilidade_transitiva})

$d|(S_{j+r}-S_{j+r-1}) \Rightarrow d|(S_{j+r}-S_j)$ $\square$ 


\begin{corollary}
O \textbf{Corolário} \autoref{corolario_divisibilidade_1} funciona mesmo se o conjunto $S$ não estiver ordenado.
\end{corollary}
\textbf{Demonstração:}
Deixaremos a demostração a cargo do leitor.


\begin{theorem}[Teorema da Divisão]\label{algoritmo_divisao}
Para todo número inteiro $a$ e qualquer número inteiro positivo $n$, existe inteiros únicos $q$ e $r$, tal que:

$a = qn + r$, $0 \leq r < n$

O valor $q$ ($q = \lfloor  \frac{a}{n} \rfloor$) é chamado de \textbf{quociente} da divisão, e o valor $r$ ($r = a \bmod n$) é chamado de \textbf{resto}
(ou \textbf{resíduo}) da divisão.
\end{theorem}
\textbf{Demonstração:}
Suponha que $q$ e $r$ não sejam únicos, ie, que exista $q^*$ e $r^*$ tal que: $a = q^*n + r^*, 0 \leq r^* < n$.

$a = qn + r = q^*n + r^* \Rightarrow (r - r^*) = (q^* - q)n \Rightarrow (r - r^*) \equiv (q^* - q)n \equiv 0 (mod$ $n)$

Porém, como $r \neq r^*$, e tanto $r$ quanto $r^*$ são menores que $n$, temos que: 

$r \not\equiv r^* (mod$ $n) \Rightarrow (r - r^*) \not\equiv 0 (mod$ $n)$

Chegando numa contradição, e assim $q$ e $r$ são únicos $\square$ \\

\begin{corollary}\label{divisibilidade_modular}
$d|n$ , $d|m \Rightarrow d|(n \bmod m)$
\end{corollary}
\textbf{Demonstração:}

$d|n \Rightarrow n = k_1d, k_1 \in \mathbb{Z}$

$d|m \Rightarrow m = k_2d, k_2 \in \mathbb{Z}$

$n = qm + (n \bmod m) \Rightarrow (n \bmod m) = n - qm$ ($\triangleright$ \autoref{algoritmo_divisao})

$(n \bmod m) = k_1d - qk_2d = (k_1 - qk_2)d \Rightarrow d|(n \bmod m)$ $\square$


\begin{corollary}\label{divisibilidade_modular2}
$d|m$ , $d|(n \bmod m) \Rightarrow d|n$
\end{corollary}
\textbf{Demonstração:}

$d|m \Rightarrow m = k_1d, k_1 \in \mathbb{Z}$

$d|(n \bmod m) \Rightarrow (n \bmod m) = k_2d, k_2 \in \mathbb{Z}$

$n = qm + (n \bmod m) \Rightarrow n = qk_1d + k_2d$ ($\triangleright$ \autoref{algoritmo_divisao})

$n = (qk_1 + k_2)d \Rightarrow d|n$ $\square$

%-----------------------------------
%	SECTION 2
%-----------------------------------
\section{Números Primos}

\begin{definition} 
Todo número inteiro n (n > 1) que têm apenas dois divisores distintos (1 e n) é chamado de número primo. Se n (n > 1) não for primo, dizemos que n é número composto.
\end{definition}


\begin{theorem}[Fatoração Única]\label{fatoracao_unica}
Um número natural qualquer $n$, pode ser escrito unicamente como um produto da forma: 
$n = p_1^{a_1}p_2^{a_2}...p_k^{a_k}$, onde os $p_i$ são números primos, $p_1 < p_2 < ... < p_k$, e os números $a_i$ são inteiros positivos.
\end{theorem}
\textbf{Demonstração:}
Deixaremos a demostração a cargo do leitor.
\textbf{Dica:} Use o fato de que o conjunto dos primos que divide um número inteiro é único, e fato de que se qualquer potência $a_i$ for alterado o valor de $n$ será alterado.



%-----------------------------------
%	SECTION 3
%-----------------------------------
\section{Máximo Divisor Comum}

\begin{definition}
O Máximo Divisor Comum de dois inteiros quaisquer $a$ e $b$ (com a ou b diferente de zero), denotado por $MDC(a,b)$, é o maior inteiro que divide ambos $a$ e $b$. 
Se $MDC(a,b) = 1$ dizemos que $a$ e $b$ são primos entre si.
\end{definition}


\begin{corollary}\label{gcd_modular}
Para números inteiros quaisquer $a$ e $b$, $MDC(a,b) = MDC(b, a \bmod b)$
\end{corollary}
\textbf{Demonstração:}
Pelo \textbf{Corolário} \autoref{divisibilidade_modular} e \autoref{divisibilidade_modular2}, temos:

$d|a, d|b \Leftrightarrow d|b, d|(a \bmod b)$

Assim, qualquer divisor de $a$ e $b$ é também divisor de $b$ e $(a \bmod b)$ (e vise versa). Implicando que o \textbf{Máximo Divisor Comum} de $a$ e $b$
é igual ao \textbf{Máximo Divisor Comum} de $b$ e $(a \bmod b)$. $\square$



\begin{corollary}\label{divisibilidade_mdc}
$MDC(a,b) = d \Rightarrow MDC(\frac{a}{d}, \frac{b}{d}) = 1$
\end{corollary}
\textbf{Demonstração:}
Suponha que $MDC(\frac{a}{d}, \frac{b}{d}) = r > 1$. Assim temos:

$r|\frac{a}{d} \Rightarrow dr|a$ ($\triangleright$ \textbf{Corolário} \autoref{divisibilidade_fracao})

$r|\frac{b}{d} \Rightarrow dr|b$ ($\triangleright$ \textbf{Corolário} \autoref{divisibilidade_fracao})

$r > 1 \Rightarrow dr > d \Rightarrow dr > MDC(a,b)$

Chegamos então numa contradição, pos $dr$ é divisor comum de $a$ e $b$, e $dr$ é maior que o \textbf{Máximo Divisor Comum} de $a$ e $b$. $\square$



\begin{corollary}\label{corolario_gcd_soma}
Para números inteiros quaisquer $a$ e $b$, $MDC(a,b) = MDC(a,a \pm b)$
\end{corollary}
\textbf{Demonstração:}
A prova dessa expressão vem do fato de que qualder divisor de $a$ e $b$, é também divisor de $(a \pm b)$.



\begin{corollary}\label{corolario_gcd_produto}
Para números inteiros quaisquer $a$ e $b$, temos:

$MDC(a,b) = 1 \Rightarrow MDC(a,bk) = MDC(a,k)$, com $k \in \mathbb{Z}$
\end{corollary}
\textbf{Demonstração:}
A prova dessa expressão vem do fato de que qualder divisor $d$ de $a$ e $bk$, é também divisor de $k$, pois $d$ não divide $b$ ($MDC(a,b) = 1$).




\subsection{Algoritmo de Euclides}
A ideia principal do \textbf{Algoritmo de Euclides} é calcular recursivamente o \textbf{Máximo Divisor Comum} de dois números baseando-se no 
\textbf{Corolário} \autoref{gcd_modular}.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Algoritmo de Euclides}\label{mdc}
\begin{algorithmic}[1]
\Procedure{$MDC (a, b)$}{}
\If {$b = 0$}
\State \Return $a$
\Else
\State \Return $MDC(b, a \bmod b)$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}




\subsection{Teorema de Bézout}

\begin{corollary}\label{bezout_conjunto_nao_nulo}
Dado o conjunto de combinações lineares positivas $S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$, onde os números $a$ e $b$ são inteiros, 
e pelo menos um desses números é diferente de zero. Temos então que $S \neq \emptyset$. 
\end{corollary}
\textbf{Demonstração:}
As combinações possíveis para $a$ e $b$ são:

$a > 0 \Rightarrow |a| = 1.a + 0.b$

$a < 0 \Rightarrow |a| = (-1).a + 0.b$

$b > 0 \Rightarrow |b| = 0.a + 1.b$

$b < 0 \Rightarrow |b| = 0.a + (-1).b$

Como não temos ambos $a$ e $b$ iguais à zero, então $S$ deve conter pelo menos $|a|$ ou $|b|$, e assim $S \neq \emptyset$ $\square$


\begin{corollary}\label{bezout_conjunto_divide}
Dado o conjunto de combinações lineares positivas $S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$, onde os números $a$ e $b$ são inteiros, 
e pelo menos um desses números é diferente de zero. Temos então que o menor número $d \in S$ divide todos elementos de $S$.
\end{corollary}
\textbf{Demonstração:}
Como $d \in S$, $\exists m,n\in\mathbb{Z} \mid d = ma + nb$.

Tome $x \in S$ qualquer. Pelo \autoref{algoritmo_divisao} $x = qd + r$, $0 \leq r < d$.

Suponha que $d\nmid x$, ie, $x \neq qd$ e $0 < r$. Como $x \in S$, $\exists m^*,n^*\in\mathbb{Z} \mid x = m^*a + n^*b$, e assim:

$x = m^*a + n^*b, x = qd + r \Rightarrow r = m^*a + n^*b - qd = m^*a + n^*b - q(ma + nb)$ 

$\Rightarrow r = (m^* - qm)a + (n^* - qn)b \Rightarrow r \in S$, pois $r > 0$

Chegando numa contrdição, pois $r \in S$, $d \in S$, $r < d$ e $d$ é o menor elemento em $S$.

Desse modo, temos que $d$ divide todos os elementos de $S$. $\square$


\begin{theorem}[Teorema de Bézout]\label{teorema_bezout}
$\forall$ $a$, $b \in \mathbb{Z}$ (com pelo menos um dos dois números diferente de zero), $\exists$ $x, y \in \mathbb{Z} \mid ax + by = mdc(a, b).$
\end{theorem}
\textbf{Demonstração:}
Tome o conjunto das combinações lineares de $a$ e $b$:

$S := \{x\in\mathbb{Z}, x>0 \mid x = ma + nb, m,n\in \mathbb{Z}\}$.

Pelo \textbf{Corolário} \autoref{bezout_conjunto_nao_nulo} sabemos que $S \neq \emptyset$. Como $S$ contém somente números positivos e não é vazio, 
$S$ está limitado inferiormente por \textit{zero} e assim, $S$ tem um elemento mínimo que chamaremos de $d$.

Como $d \in S$, então existe $u, v\in \mathbb{Z}$, tal que, $d = ua + vb$. Pelo \textbf{Corolário} \autoref{bezout_conjunto_divide}, sabemos que $d$ divide todos elementos em $S$, em particular:

$d$ divide $|a|$ e $|b| \Rightarrow d|MDC(a,b) \Rightarrow 0 < d \leq MDC(a,b)$

Por outro lado, $MDC(a,b)$ também divide $a$ e $b$:

$MDC(a,b)|a$ e $MDC(a,b)|b \Rightarrow MDC(a,b)|(ua + vb)$

$ \Rightarrow MDC(a,b)|d \Rightarrow MDC(a,b) \leq d$

$MDC(a,b)\leq d$ e $d \leq MDC(a,b) \Rightarrow MDC(a,b) = d \Rightarrow MDC(a,b) \in S$ $\square$



%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Crivo de Erastóteles}

O \textit{Crivo de Erastótenes} é um algoritmo criado pelo matemático \textbf{Erastótenes} (a.C. 285-194 a.C.) para o cálculo de números primos
até um certo valor limite $N$.
O algoritmo mantém uma tabela com $N$ elementos, e para cada primo, começando pelo número $2$, marca na tabelo os números compostos múltiplos desses primos.
Desse modo, ao final do algoritmo, os elementos não marcados são números primos.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Crivo de Erastótenes paro o cálculo de números primos}\label{crivo_erastotenes}
\begin{algorithmic}[1]
\Procedure{CrivoErastótenes (N)}{}
\State $isPrime[] \gets \text{new Array}[N]$ \Comment{$isPrime[]$ é um vetor booleano}

\For {($p = 2 \text{; } p \leq N \text{; } p++)$}
\State $isPrime[p] \gets true$
\EndFor

\For {($p = 2 \text{; } p^2 \leq N \text{; } p++)$}
\If {$isPrime[p] = false$}
\State \textbf{continue}
\EndIf
\For {($n = p^2 \text{; } n \leq N \text{; } n = n+p)$}
\State $isPrime[n] \gets false$
\EndFor
\EndFor

\State \Return{$isPrime[]$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
TODO





%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Problemas Propostos}


%----------------------------------------------------------------------------------------
\subsection{UVA-10407}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1348}{10407 - Simple Division} \\

\textbf{Resumo:} 
Tome $P(S) := \{ x \in \mathbb{Z} \mid  \forall a , b \in S , a \equiv b ( mod$ $x)\}$ em que $S \subset \mathbb{Z}$.

O problema consiste em encontrar o valor máximo de $P(S)$ dado um conjunto $S$.
\\

\textbf{Solução:} 
Seja $S = \{S_1, S_2, S_3, ..., S_n\}$, com $n = |S|$, o conjunto dado pelo problema (assumiremos que os valores de S estão ordenados crescentemente).

Tome um número qualquer $d \in P(S)$. Por definição temos que $\forall S_i, S_j \in S$, $S_i \equiv S_j ( mod$ $d) \Rightarrow $ 
$ (S_i-S_j) \equiv 0 ( mod$ $d) \Rightarrow d \mid (S_i-S_j)$ .

Pelo \textbf{Corolário} \autoref{corolario_divisibilidade_1} sabemos que:

$d | (S_i-S_{i-1})$, $ \forall i \in \mathbb{N}, 2 \leq i \leq n \Rightarrow d | (S_i-S_j)$, $ \forall S_i, S_j \in S \Rightarrow d \in P(S)$.

E desse modo, para calcular o valor máximo de $P(S)$ só precisamos calcular o Máximo Divisor Comum das diferenças $(S_i-S_{i-1})$ com $i$ variando de $2$ à $n$ $\square$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Simple Division}\label{euclid}
\begin{algorithmic}[1]
\Procedure{GetMaximumValue (S)}{}
\State $S \gets sort(S)$ \Comment{sort(X) retorna o conjunto X ordenado.} 
\State $maxValue \gets 0$
\For {i := 2 to |S|} 
\State $maxValue \gets MDC(maxValue, S_i - S_{i-1})$
\EndFor
\State \Return{$maxValue$}
\EndProcedure
\end{algorithmic}
\end{algorithm}


