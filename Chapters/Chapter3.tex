% Chapter 3

\chapter{Funções Aritméticas} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{$\varphi$ de Euler}

\begin{definition}
A Função Totiente de Euler, denotada por $\varphi(n)$, é a função aritmética que conta o número 
de inteiros positivos menores ou iguais a $n$ que são primos entre si com $n$.

$\varphi(n) := |\{ x \in \mathbb{N}^{*} \mid MDC(x,n) = 1 \}|$
\end{definition}


\begin{theorem}\label{phi_potencia}
$\varphi(n^k) = n^{k-1}\varphi(n)$, para inteiros positiovos quaisquer $n$ e $k$. Em particular 
$\varphi(p^k) = (p^k - p^{k-1})$, para $p$ primo.%, e $k \in \mathbb{N}^{*}$.
\end{theorem}
\textbf{Demonstração:}



\begin{theorem}\label{phi_multiplicativa}
$\varphi(n)$ é função multiplicativa, ie, $\varphi(mn) = \varphi(m)\varphi(n)$ para $MDC(m,n) = 1$.
\end{theorem}
\textbf{Demonstração:}



\begin{theorem}[Fórmula Produto de Euler]
$\varphi(n) = n \prod_{p|n}(1 - \frac{1}{p})$
\end{theorem}
\textbf{Demonstração:}
Pelo \autoref{fatoracao_unica}, \autoref{phi_potencia}, \autoref{phi_multiplicativa} segue as seguintes recorrências:

$\varphi(n) = \varphi(p_1^{a_1}p_2^{a_2}...p_k^{a_k})$

$\varphi(n) = \varphi(p_1^{a_1})\varphi(p_2^{a_2})...\varphi(p_k^{a_k})$

$\varphi(n) = (p_1^{a_1} - p_1^{a_1-1})(p_2^{a_2} - p_2^{a_2-1})...(p_k^{a_k} - p_k^{a_k-1})$

$\varphi(n) = p_1^{a_1}p_2^{a_2}...p_k^{a_k}(1 - 1/p_1)(1 - 1/p_2)...(1 - 1/p_k)$

$\varphi(n) = n \prod_{p|n}(1 - \frac{1}{p})$ $\square$

%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Sequência de Fibonacci}

\begin{definition}
A sequência de Fibonacci $Fib_n$ é uma sequência de números inteiros positivos em que cada termo subsequente corresponde a some dos dois termos anteriores.

\[
 Fib_n :=
  \begin{cases}
   1 & \text{se } n = 1\text{ ou }n = 2 \\
   Fib_{n-1} + Fib_{n-2} & \text{se } n \geq 3
  \end{cases}
\]
\end{definition}


\begin{corollary}\label{gcd_consecutivo_fib}
$MDC(Fib_n, Fib_{n-1}) = 1$, para $n \geq 2$
\end{corollary}
\textbf{Demonstração:}
Tome os primeiros termos da sequência de fibonacci: $1, 1, 2, 3, 5, 8,...$.
Claramente a expressão acima funciona para os primeiros termos.
Assuma que a expressão funciona para um inteiro qualquer $(k-1) > 2$ ($MDC(Fib_{k-1}, Fib_{k-2}) = 1$).

Provaremos por indução que a expressão sempre funciona.

$MDC(Fib_{k}, Fib_{k-1}) = MDC(Fib_{k-1} + Fib_{k-2}, Fib_{k-1})$

$MDC(Fib_{k-1} + Fib_{k-2}, Fib_{k-1}) = MDC(Fib_{k-2}, Fib_{k-1})$ ($\triangleright$ Pelo \textbf{Corolário} \autoref{corolario_gcd_soma})

Logo, temos que:

$MDC(Fib_{k}, Fib_{k-1}) = MDC(Fib_{k-2}, Fib_{k-1}) = 1$ $\square$



\begin{corollary}\label{gcd_combinacao_fib}
$Fib_{m+n} = Fib_mFib_{n+1} + Fib_{m-1}Fib_n$
\end{corollary}
\textbf{Demonstração:} Provaremos esse corolário por indução no índice $n$.

A base da indução será, $n=2$:

$Fib_{m+2} = Fib_m + Fim_{m+1} = Fib_m + Fib_m + Fib_{m-1}$

$Fib_{m+2} = 2Fib_m + 1Fib_{m-1} = Fib_mFib_{3} + Fib_{m-1}Fib_2$

Assumindo que a expressão funciona para todos os valores menores que $n$, temos:

$Fib_{m+n} = Fib_{m+n-2} + Fib_{m+n-1}$

$Fib_{m+n} = (Fib_{m}Fib_{n-1} + Fib_{m-1}Fib_{n-2}) + (Fib_{m}Fib_{n} + Fib_{m-1}Fib_{n-1})$

$Fib_{m+n} = Fib_m(Fib_{n-1} + Fib_{n}) + Fib_{m-1}(Fib_{n-2} + Fib_{n-1})$

$Fib_{m+n} = Fib_mFib_{n+1} + Fib_{m-1}Fib_n$ $\square$ 


\begin{theorem}\label{fibonacci_mdc}
$MDC(Fib_m, Fib_n) = Fib(MDC(m, n)), \forall m, n \in \mathbb{Z}$
\end{theorem}
\textbf{Demonstração:}
Primeiro escreva $n = qm + r, 0 \leq r < m$ (\autoref{algoritmo_divisao}). Assim temos:

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fin_{qm + r})$

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{qm}Fib_{r+1} + Fib_{qm-1}Fib_{r})$ ($\triangleright$ \textbf{Corolário} \autoref{gcd_combinacao_fib}).

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{qm-1}Fib_{r})$

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{r})$ ($\triangleright$ \textbf{Corolário} \autoref{corolario_gcd_produto}).


%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Problemas Propostos}


%----------------------------------------------------------------------------------------
\subsection{UVA-11424}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2419}{11424 - GCD - Extreme (I)} \\

\textbf{Resumo:}
É dado um inteiro positivo $N$ ($1 < N < 200001$). O problema consiste em calcular o mais rápido possível a expressão:

$G(N) = \sum_{i=1}^{N-1}\sum_{j=i+1}^{N}MDC(i,j)$.
\\

\textbf{Solução:}
Trivialmente a expressão acima pode ser calculada em tempo proporcional à $O(n^2log(N))$, porém essa solução consome muito tempo e não será aceita no Judge Online. Vamos então mostrar uma solução mais eficiente.
\\

Primeiramente reescrevemos a expressão acima da seguinte maneira:

$G(N) = \sum_{j=2}^N\sum_{i=1}^{j-1}MDC(i,j)$ ( $\rhd$ Observe que as expressão são equivalentes).

Tome agora a função $F(M) = \sum_{i=1}^{M-1}MDC(i, M)$ $\Rightarrow$ $G(N) = \sum_{j=2}^NF(j)$.

Sabemos que todos os valores resultantes do método $MDC(i,M)$ calculados em $F(M)$ são divisores de $M$. Desse modo, podemos reescrever $F(M)$ da seguinte maneira:

$F(M) = \sum_{i=1}^{M-1}MDC(i, M) = \sum_{l=1}^{n}\lambda_l d_l$, em que, $d_1, d_2,..., d_n$ são os divisores de $M$, $\lambda_l$ é o número de vezes que o divisor $d_l$ aparece na somatória $\sum_{i=1}^{M-1}MDC(i,N)$, e $n$ é o número de divisores de $M$.
\\

Pelo Corolario \autoref{divisibilidade_mdc} temos que: $MDC(i,M) = d_l \Rightarrow MDC(i/d_l,M/d_l) = 1$. Logo o número de vezes que o divisor $d_l$ aparece na somatória, será igual ao número de primos entre si com $(M/d_l)$, ie, $\lambda_l = \varphi(M/d_l)$.

Reescrevendo novamente $F(M)$, temos:

$F(M) = \sum_{i=1}^{M-1}MDC(i, M) = \sum_{l=1}^n \lambda_l d_l = \sum_{l=1}^n \varphi(M/d_l) d_l$.

$G(N) = \sum_{j=2}^N \sum_{l=1}^n \varphi(j/d_l)d_l$ $\square$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{GCD - Etreme(I)}\label{gcd_extreme}
\begin{algorithmic}[1]
\Procedure{G (N)}{}
\State $\varphi[] \gets PHI(N)$
\State $solution \gets 0$
\For {$j$ := $2$ to $N$}
\For {\textbf{each} divisor $d$ de $j$}
\State $solution \gets solution + \varphi[j/d] d$
\EndFor
\EndFor
\State \Return{$solution$}
\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
O método $PHI(N)$ na linha 2 consome tempo proporcional à $O(N\sqrt{N})$.

O número de divisores de $j$ é proporcional à $O(\sqrt{N})$, já que $j \leq N$.

Assim a complexidade das linhas 4, 5, 6 do algoritmo é $O(N\sqrt{N})$.

Complexidade final do algoritmo: $O(N\sqrt{N})$.

\textbf{OBS.:} Para resolver o problema no Judge Online será preciso armazenar as soluções usando \href{https://linux.ime.usp.br/~stefanot/mac499/template.pdf}{Programação Dinâmica}.






%----------------------------------------------------------------------------------------
\subsection{TJU-3506}
\href{http://acm.tju.edu.cn/toj/showp3506.html}{3506 - Euler Function} \\

\textbf{Resumo:}
São dados dois números positivos $n$, $m$ ($1 < n < 10^7$, $1 < m < 10^9$).
O problenas consiste em calcular a expressão: $\varphi(n^m) \bmod 201004.$
\\

\textbf{Solução:}
Pelo \autoref{phi_potencia}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{GCD - Etreme(I)}\label{gcd_extreme}
\begin{algorithmic}[1]
\Procedure{G (N)}{}
\State $\varphi[] \gets PHI(N)$
\State $solutuion \gets 0$
\For {$j$ := $2$ to $N$}
\For {\textbf{each} divisor $d$ de $j$}
\State $solution \gets solution + \varphi[j/d] d$
\EndFor
\EndFor
\State \Return{$solutuion$}
\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}


%----------------------------------------------------------------------------------------
\subsection{CodeChef-MODEFB}
\href{https://www.codechef.com/problems/MOREFB}{71544 - Another Fibonacci}\\

\textbf{Resumo:}
São dados dois números inteiros $N$, $K$ ($1 \leq N \leq 50000$, $1 \leq K \leq N$) e um conjunto $S \subset \mathbb{N}$ com $N$ elementos, tal que, $\forall s \in S, 1 \leq s \leq 10^9$.
O problenas consiste em calcular a expressão: $F(S) = \sum_{A \subset S \hspace{1mm} e\hspace{1mm} |A| = K}^{} Fib(sum(A))$, onde $sum(A) = \sum_{a \in A}a$. %$\varphi(n^m) \bmod 201004.$
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Another Fibonacci}
\begin{algorithmic}[1]
\Procedure{F (S)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}




%----------------------------------------------------------------------------------------
\subsection{UVA-10311}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1252}{10311 - Goldbach and Euler}\\

\textbf{Resumo:}
É dado um número inteiro $n$ ($0 < n \leq 10^8$). O problema consite em verificar se $n$ pode, ou não pode, ser escrito como a soma de dois números primos. 
E em caso afirmativo encontrar o valor desses dois primos.
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Goldbach and Euler}
\begin{algorithmic}[1]
\Procedure{FindTwoPrimesSum (n)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}



%----------------------------------------------------------------------------------------
\subsection{Codeforces-227E}
\href{http://codeforces.com/contest/227/problem/E}{227E - Anniversary}\\

\textbf{Resumo:}

É dado um número inteiro $n$ ($0 < n \leq 10^8$). O problema consite em verificar se $n$ pode, ou não pode, ser escrito como a soma de dois números primos. 
E em caso afirmativo encontrar o valor desses dois primos.
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Goldbach and Euler}
\begin{algorithmic}[1]
\Procedure{FindTwoPrimesSum (n)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}


