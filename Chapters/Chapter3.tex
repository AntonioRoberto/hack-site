% Chapter 3

\chapter{Funções Aritméticas} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{$\varphi$ de Euler}

\begin{definition}
A Função Totiente de Euler, denotada por $\varphi(n)$, é a função aritmética que conta o número 
de inteiros positivos menores ou iguais a $n$ que são primos entre si com $n$.

$\varphi(n) := |\{ x \in \mathbb{N}^{*} \mid MDC(x,n) = 1 \}|$
\end{definition}


\begin{theorem}\label{phi_potencia}
$\varphi(n^k) = n^{k-1}\varphi(n)$, para inteiros positiovos quaisquer $n$ e $k$. Em particular 
$\varphi(p^k) = (p^k - p^{k-1})$, para $p$ primo.%, e $k \in \mathbb{N}^{*}$.
\end{theorem}
\textbf{Demonstração:}
TODO


\begin{theorem}\label{phi_multiplicativa}
$\varphi(n)$ é função multiplicativa, ie, $\varphi(mn) = \varphi(m)\varphi(n)$ para $MDC(m,n) = 1$.
\end{theorem}
\textbf{Demonstração:}
TODO


\begin{theorem}[Fórmula Produto de Euler]
$\varphi(n) = n \prod_{p|n}(1 - \frac{1}{p}) = n \prod_{p|n}(\frac{p-1}{p})$
\end{theorem}
\textbf{Demonstração:}

$\varphi(n) = \varphi(p_1^{a_1}p_2^{a_2}...p_k^{a_k})$ ($\triangleright$ \autoref{fatoracao_unica})

$\varphi(n) = \varphi(p_1^{a_1})\varphi(p_2^{a_2})...\varphi(p_k^{a_k})$ ($\triangleright$ \autoref{phi_multiplicativa})

$\varphi(n) = (p_1^{a_1} - p_1^{a_1-1})(p_2^{a_2} - p_2^{a_2-1})...(p_k^{a_k} - p_k^{a_k-1})$ ($\triangleright$ \autoref{phi_potencia})

$\varphi(n) = p_1^{a_1}p_2^{a_2}...p_k^{a_k}(1 - 1/p_1)(1 - 1/p_2)...(1 - 1/p_k)$

$\varphi(n) = n \prod_{p|n}(1 - \frac{1}{p})$ $\square$\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Calcula os primeiros N termos da função $\varphi$}
\begin{algorithmic}[1]
\Procedure{$PHI (N)$}{}
\State $\varphi[] \gets new Array[N]$
\For {$(p = 1 \text{; } p \leq N \text{; } p++)$}
\State $\varphi[p] \gets p$
\EndFor

\For {$(p = 2\text{; } p \leq N\text{; } p++)$}

\If {$\varphi[p] \neq p$} \Comment{$\varphi[p] \neq p \Leftrightarrow p\text{ não é primo}$}
\State \textbf{continue}
\EndIf

\For {$(n = p\text{; } n \leq N\text{; } n = n+p)$}
\State $\varphi[n] \gets \varphi[n] (\frac{p-1}{p})$
\EndFor

\EndFor

\State \Return {$\varphi[]$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Teorema de Euler}

\begin{theorem}[Teorema de Euler]\label{teorema_de_euler}
Dados números inteiros $a$ e $n$ primos entre si, temos que:
$a^{\varphi(n)} \equiv 1 (\bmod$ $n)$
\end{theorem}
\textbf{Demonstração:}
TODO usa residuos completo mod m



%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Sequência de Fibonacci}

\begin{definition}
A sequência de Fibonacci $Fib_n$ é uma sequência de números inteiros positivos em que cada termo subsequente corresponde a some dos dois termos anteriores.

\[
 Fib_n :=
  \begin{cases}
   0 & \text{se } n = 0 \\
   1 & \text{se } n = 1 \\
   Fib_{n-1} + Fib_{n-2} & \text{se } n \geq 2
  \end{cases}
\]
\end{definition}


\begin{corollary}\label{gcd_consecutivo_fib}
$MDC(Fib_n, Fib_{n-1}) = 1$, para $n \geq 2$
\end{corollary}
\textbf{Demonstração:}
Tome os primeiros termos da sequência de fibonacci: $1, 1, 2, 3, 5, 8,...$.
Claramente a expressão acima funciona para os primeiros termos.
Assuma que a expressão funciona para um inteiro qualquer $(k-1) > 2$ ($MDC(Fib_{k-1}, Fib_{k-2}) = 1$).

Provaremos por indução que a expressão sempre funciona.

$MDC(Fib_{k}, Fib_{k-1}) = MDC(Fib_{k-1} + Fib_{k-2}, Fib_{k-1})$

$MDC(Fib_{k-1} + Fib_{k-2}, Fib_{k-1}) = MDC(Fib_{k-2}, Fib_{k-1})$ ($\triangleright$ Pelo \textbf{Corolário} \autoref{corolario_gcd_soma})

Logo, temos que:

$MDC(Fib_{k}, Fib_{k-1}) = MDC(Fib_{k-2}, Fib_{k-1}) = 1$ $\square$



\begin{corollary}\label{gcd_combinacao_fib}
$Fib_{m+n} = Fib_mFib_{n+1} + Fib_{m-1}Fib_n$
\end{corollary}
\textbf{Demonstração:} Provaremos esse corolário por indução no índice $n$.

A base da indução será, $n=2$:

$Fib_{m+2} = Fib_m + Fim_{m+1} = Fib_m + Fib_m + Fib_{m-1}$

$Fib_{m+2} = 2Fib_m + 1Fib_{m-1} = Fib_mFib_{3} + Fib_{m-1}Fib_2$

Assumindo que a expressão funciona para todos os valores menores que $n$, temos:

$Fib_{m+n} = Fib_{m+n-2} + Fib_{m+n-1}$

$Fib_{m+n} = (Fib_{m}Fib_{n-1} + Fib_{m-1}Fib_{n-2}) + (Fib_{m}Fib_{n} + Fib_{m-1}Fib_{n-1})$

$Fib_{m+n} = Fib_m(Fib_{n-1} + Fib_{n}) + Fib_{m-1}(Fib_{n-2} + Fib_{n-1})$

$Fib_{m+n} = Fib_mFib_{n+1} + Fib_{m-1}Fib_n$ $\square$ 


\begin{theorem}\label{fibonacci_mdc}
$MDC(Fib_m, Fib_n) = Fib_{MDC(m, n)}, \forall m, n \in \mathbb{Z}$
\end{theorem}
\textbf{Demonstração:}

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{qm + r})$ ($\triangleright$ \autoref{algoritmo_divisao}, $n = qm + r, 0 \leq r < n$)

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{qm}Fib_{r+1} + Fib_{qm-1}Fib_{r})$ ($\triangleright$ \textbf{Corolário} \autoref{gcd_combinacao_fib}).

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{qm-1}Fib_{r})$

Pelo \textbf{Corolário} \autoref{corolario_gcd_produto} e sabendo que $MDC(Fib_m,Fib_{qm-1})=1$, temos:

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{r})$

$MDC(Fib_m, Fib_n) = MDC(Fib_m, Fib_{n \bmod m})$

Se tirarmos o símbolo funcional $Fib$, a última equação forma um passo do \textbf{Algoritmo de Euclides} ($MDC(m,n) = MDC(m, n \bmod m)$).

Podemos continuar esse processo até que o resto $r$ se torne $0$. O último resto não-nulo será
exatamente o Máximo Divisor Comum do dois números originais.

Desse modo, se aplicar-mos o \textbf{Algoritmo de Euclides} em $Fib_m$ e $Fib_n$ funciona da mesma maneira que se aplicar-mos aos índice $m$ e $n$.
E assim, ao chegarmos na base da recursão, $MDC(m,n) = MDC(s,0) = s$, teremos também: $MDC(Fib_m,Fib_n) = MDC(Fib_s,0) = Fib_s = Fib_{MDC(m,n)}$ $\square$.


\begin{theorem}
$Fib_n = \frac{\sqrt{5}}{5}((\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n)$
\end{theorem}
\textbf{Demonstração:}

A demostrção asseguir foi baseada no no livro: \textit{OLIVEIRA SANTOS, José Plínio de. Introdução à Teoria dos Números. IMPA, 1998. 85 p.}

$Fib_{n+1} = Fib_n + Fib_{n-1}$

$Fib_{n+1} - kFib_n = Fib_n + Fib_{n-1} - kFib_n$

$Fib_{n+1} - kFib_n = Fib_n + Fib_{n-1} - kFib_n + (kFib_{n-1}-kFib_{n-1}) + (k^2Fib_{n-1}-k^2Fib_{n-1})$

$Fib_{n+1} - kFib_n = (1 - k)(Fib_n - kFib_{n-1}) + (1 + k - k^2)Fib_{n-1}$

Se denotarmos as raízes de $k^2-k-1=0$ por $k_1$ e $k_2$, teremos que $k_1=\frac{1-\sqrt{5}}{2}$ e $k_2=\frac{1+\sqrt{5}}{2}$. 

$Fib_{n+1} - k_1Fib_b = k_2(Fib_n - k_1Fib_{n-1})$

$Fib_{n+1} - k_2Fib_b = k_1(Fib_n - k_2Fib_{n-1})$

Por iterações sucessivas dessas duas equações teremos que:

$Fib_{n+1} - k_1Fib_b = k_2^n(Fib_1 - k_1Fib_0) = k_2^n$

$Fib_{n+1} - k_2Fib_b = k_1^n(Fib_1 - k_2Fib_0) = k_1^n$

Subtraindo membro à membro nos dá:

$Fib_n(k_2 - k_1) = k_2^n - k_1^n$

$Fib_n = \frac{k_2^n - k_1^n}{k_2 - k_1}$

$Fib_n = \frac{(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n}{(\frac{1+\sqrt{5}}{2}) - (\frac{1-\sqrt{5}}{2})}$

$Fib_n = \frac{\sqrt{5}}{5}((\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n)$ $\square$




%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Problemas Propostos}


%----------------------------------------------------------------------------------------
\subsection{UVA-11424}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2419}{11424 - GCD - Extreme (I)} \\

\textbf{Resumo:}
É dado um inteiro positivo $N$ ($1 < N < 200001$). O problema consiste em calcular o mais rápido possível a expressão:

$G(N) = \sum_{i=1}^{N-1}\sum_{j=i+1}^{N}MDC(i,j)$.
\\

\textbf{Solução:}
Trivialmente a expressão acima pode ser calculada em tempo proporcional à $O(n^2log(N))$, porém essa solução consome muito tempo e não será aceita no Judge Online. Vamos então mostrar uma solução mais eficiente.
\\

Primeiramente reescrevemos a expressão acima da seguinte maneira:

$G(N) = \sum_{j=2}^N\sum_{i=1}^{j-1}MDC(i,j)$ ( $\rhd$ Observe que as expressão são equivalentes).

Tome agora a função $F(M) = \sum_{i=1}^{M-1}MDC(i, M)$ $\Rightarrow$ $G(N) = \sum_{j=2}^NF(j)$.

Sabemos que todos os valores resultantes do método $MDC(i,M)$ calculados em $F(M)$ são divisores de $M$. Desse modo, podemos reescrever $F(M)$ da seguinte maneira:

$F(M) = \sum_{i=1}^{M-1}MDC(i, M) = \sum_{l=1}^{n}\lambda_l d_l$, em que, $d_1, d_2,..., d_n$ são os divisores de $M$, $\lambda_l$ é o número de vezes que o divisor $d_l$ aparece na somatória $\sum_{i=1}^{M-1}MDC(i,N)$, e $n$ é o número de divisores de $M$.
\\

Pelo Corolario \autoref{divisibilidade_mdc} temos que: $MDC(i,M) = d_l \Rightarrow MDC(i/d_l,M/d_l) = 1$. Logo o número de vezes que o divisor $d_l$ aparece na somatória, será igual ao número de primos entre si com $(M/d_l)$, ie, $\lambda_l = \varphi(M/d_l)$.

Reescrevendo novamente $F(M)$, temos:

$F(M) = \sum_{i=1}^{M-1}MDC(i, M) = \sum_{l=1}^n \lambda_l d_l = \sum_{l=1}^n \varphi(M/d_l) d_l$.

$G(N) = \sum_{j=2}^N \sum_{l=1}^n \varphi(j/d_l)d_l$ $\square$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{GCD - Etreme(I)}\label{gcd_extreme}
\begin{algorithmic}[1]
\Procedure{G (N)}{}
\State $\varphi[] \gets PHI(N)$
\State $solution \gets 0$
\For {$j$ := $2$ to $N$}
\For {\textbf{each} divisor $d$ de $j$}
\State $solution \gets solution + \varphi[j/d] d$
\EndFor
\EndFor
\State \Return{$solution$}
\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
O método $PHI(N)$ na linha 2 consome tempo proporcional à $O(N\sqrt{N})$.

O número de divisores de $j$ é proporcional à $O(\sqrt{N})$, já que $j \leq N$.

Assim a complexidade das linhas 4, 5, 6 do algoritmo é $O(N\sqrt{N})$.

Complexidade final do algoritmo: $O(N\sqrt{N})$.

\textbf{OBS.:} Para resolver o problema no Judge Online será preciso armazenar as soluções usando \href{https://linux.ime.usp.br/~stefanot/mac499/template.pdf}{Programação Dinâmica}.






%----------------------------------------------------------------------------------------
\subsection{TJU-3506}
\href{http://acm.tju.edu.cn/toj/showp3506.html}{3506 - Euler Function} \\

\textbf{Resumo:}
São dados três números positivos $n$, $m$ ($1 < n < 10^7$, $1 < m < 10^9$) e $d = 201004$.
O problema consiste em calcular a expressão: $\varphi(n^m) \bmod d$.
\\

\textbf{Solução:}
Pelo \autoref{phi_potencia}, temos: 

$\varphi(n^m) \bmod d = (n^{m-1}\varphi(n)) \bmod d$

$\varphi(n^m) \bmod d = ((n^{m-1} \bmod d)(\varphi(n)) \bmod d) \bmod d)$

Desse modo, podemos calcular a primeiro fator do produto ($n^{m-1} \bmod d$) usando $EXPMOD()$ e a segundo fator com o método $PHI()$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Euler Functions}
\begin{algorithmic}[1]
\Procedure{$PhiEulerPotential (n, m, d)$}{}
\State $\varphi[] \gets PHI(n)$
\State $exp \gets EXPMOD(n, m-1, d)$
\State $solution \gets (exp$ $\varphi[n]) \bmod d$
\State \Return{$solution$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
As linhas $3$ e $4$ do algoritmo consomem tempo proporcional à $O(\log m)$ e $O(1)$ respectivamente.
Se precalcular-mos o vetor $\varphi[]$, temos que a complexidade total para calcular cada instância do problema será: $O(\log m)$ 



%----------------------------------------------------------------------------------------
\subsection{CodeChef-IITK2P05}
\href{https://www.codechef.com/problems/IITK2P05}{IITK2P05 - Factorization}\\

\textbf{Resumo:}
É dado um inteiro $N$ ($2 \leq N \leq 10^18$) e o valora de $\varphi(N)$.

O problema consiste em fatorizar $N$. 
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Fatoração de $N$}
\begin{algorithmic}[1]
\Procedure{Factorization (N)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}




%----------------------------------------------------------------------------------------
\subsection{CodeChef-MODEFB}
\href{https://www.codechef.com/problems/MOREFB}{71544 - Another Fibonacci}\\

\textbf{Resumo:}
São dados dois números inteiros $N$, $K$ ($1 \leq N \leq 50000$, $1 \leq K \leq N$) e um conjunto $S \subset \mathbb{N}$ com $N$ elementos, tal que, $\forall s \in S, 1 \leq s \leq 10^9$.

Tome a seguinte função:

$F(S) = \sum_{A \subset S \hspace{1mm} e\hspace{1mm} |A| = K}^{} Fib(sum(A))$, onde $sum(A) = \sum_{a \in A}a$. %$\varphi(n^m) \bmod 201004.$

O problema consiste em calcular a expressão:  
$F(S) \bmod 99991 $
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Another Fibonacci}
\begin{algorithmic}[1]
\Procedure{F (S)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}







%----------------------------------------------------------------------------------------
\subsection{UVA-10311}
\href{https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1252}{10311 - Goldbach and Euler}\\

\textbf{Resumo:}
É dado um número inteiro $n$ ($0 < n \leq 10^8$). O problema consite em verificar se $n$ pode, ou não pode, ser escrito como a soma de dois números primos. 
E em caso afirmativo encontrar o valor desses dois primos.
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Goldbach and Euler}
\begin{algorithmic}[1]
\Procedure{FindTwoPrimesSum (n)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}



%----------------------------------------------------------------------------------------
\subsection{Codeforces-227E}
\href{http://codeforces.com/contest/227/problem/E}{227E - Anniversary}\\

\textbf{Resumo:}
\\

\textbf{Solução:}
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Anniversary}
\begin{algorithmic}[1]
\Procedure{FindTwoPrimesSum (n)}{}

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}


