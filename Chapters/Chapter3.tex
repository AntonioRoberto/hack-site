% Chapter 3

\chapter{Aritmética Modular} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Congruência}

\begin{definition}
Para $a$ e $b$ inteiros, dizemos que $a$ é congruente à $b$ módulo $m$ ($a \equiv b (mod$ $m), m > 0$) 
se $a$ e $b$ produzem o mesmo resto na divisão por $m$ (ie, $m|(a-b)$).
Caso contrário ($m\nmid (a-b)$), dizemos que $a$ não é congruente à $b$ módulo $m$ ($a \not\equiv b (mod $ $m)$).
\\
\end{definition}


\begin{definition}
Dizemos que o conjunto de inteiros $S = \{s_1, s_2, ..., s_k\}$ é um sistema completo de resíduos modulo $n$ se:
%\begin{enumerate}
$\forall a \in \mathbb{Z}, \exists! s_i \in S \mid a \equiv s_i (mod$ $n)$
%\item$s_i \not\equiv s_j (mod $ $n)$ para $i \neq j$
%\\
%\end{enumerate}
\end{definition}


\begin{proposition}\label{corolario_implicacao_mdc}
Dados inteiros $a$, $b$, $c$, $d$ com $MDC(c,d)=1$, temos que: 

$ac \equiv bc (mod$ $d) \Rightarrow a \equiv b (mod$ $d)$.
\end{proposition}
\textbf{Demonstração:}

$ac \equiv bc (mod$ $d) \Rightarrow d|(ac-bc) \Rightarrow d|c(a-b) \Rightarrow d|(a-b)$, já que $MDC(c,d)=1$

$\Rightarrow a \equiv b (mod$ $d)$. $\square$
\\


\begin{proposition}\label{residuo_completo_1n}
O conjunto $R = \{0, 1, 2, 3,...,n-1\}$, é um sistema completo de resíduos módulo $n$.
\end{proposition}
\textbf{Demonstração:}
Pelo \autoref{algoritmo_divisao} sabemos que para qualquer inteiro $a$, existe $q, r$ tal que, $a = qn + r, 0 \leq r < n$. Assim, $a\equiv r(mod$ $n)$, com $r \in R$. $\square$
\\

\begin{theorem}
Se o conjunto $S = \{s_0, s_1, s_2, ..., s_{k-1}\}$ é um sistema completo de resíduos módulo $n$, então $k=n$.
\end{theorem}
\textbf{Demonstração:}
Tome o conjunto $R = \{0, 1, 2, 3,...,n-1\}$. Pela \textbf{Proposição} \autoref{residuo_completo_1n} sabemos que $R$ é um sistema completo de resíduos módulo $n$.

Podemos concluir então, que cada elemento $s_i$ de $S$ é congruente a exatamente um dos elementos $r_i$ em $R$, o que nos garante $|S| \leq |R|$. 
Por outro lado, o conjunto $S$ é por definição um sistema completo de resíduos módulo $n$, e desse modo cada elemento $r_i$ de $R$ é congruente a exatamente um dos elementos $s_i$ em $S$, o que nos garante $|R| \leq |S|$.
Assim, como $|S| \leq |R|$ e $|R| \leq |S|$, temos que $|R| = n = k = |S|$. $\square$
\\



%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Congruência Linear}

\begin{definition}
Congruências da forma $ax \equiv b (mod$ $m)$, onde $a$, $b$ e $m$ são inteiros e $x$ é uma incógnita, são chamadas de \textit{Congruências Lineares}.
\newline
\end{definition}


\begin{definition}\label{def_residuo_quadratico}
Um inteiro $q$ é chamado de \textbf{Resíduo Quadrático} módulo $n$ se é congruente a um \textit{quadrado perfeito} módulo $n$, ie, se existe $x$, tal que:
$x^2 \equiv q$ $(mod$ $n)$. 
\newline 
\end{definition}

\begin{proposition}\label{congruencia_linear_ida}
$ax \equiv b (mod$ $m)$ tem solução $\Rightarrow$ $MDC(a,m)|b$
\end{proposition}
\textbf{Demonstração:}
Suponha que $\exists x\in\mathbb{Z}$, tal que $ax\equiv b(mod$ $m)$, assim temos:

$ax\equiv b(mod$ $m) \Rightarrow m|(b-ax) \Rightarrow \exists! r\in\mathbb{Z}$ tal que $(b-ax) = mr$

$\Rightarrow b = mr + ax \Rightarrow MDC(a,m)|b$, pois $MDC(a,m)$ divide tanto $a$ como $m$. $\square$
\newline


\begin{proposition}\label{congruencia_linear_volta}
$ax \equiv b (mod$ $m)$ tem solução $\Leftarrow$ $MDC(a,m)|b$
\end{proposition}
\textbf{Demonstração:}

$MDC(a,m)|b \Rightarrow (ax+my)|b$ ($\triangleright$ \autoref{teorema_bezout})

$\Rightarrow \exists!r\in\mathbb{Z}$ tal que, $b=(ax + my)r \Rightarrow b = (xr)a + (yr)m$

$\Rightarrow b \equiv xra + yrm$ $(mod$ $m) \Rightarrow b \equiv xra$ $(mod$ $m)$

E assim, a \textbf{Congruência Linear} $az\equiv b (mod$ $m)$, tem solução $z=xr$. $\square$

\begin{corollary}\label{teorema_congruencia_linear_ida_volta}
$ax \equiv b (mod$ $m)$ tem solução $\Leftrightarrow$ $MDC(a,m)|b$
\end{corollary}
\textbf{Demonstração:}
Segue trivialmente das \textbf{Proposições} \autoref{congruencia_linear_ida} e \autoref{congruencia_linear_volta}.




\begin{theorem}\label{sistemo_completp_residuo}
O conjunto $S = \{s_0, s_1, s_2,..., s_{n-1}\}$ com $s_i = im + p$, $m, n, p \in \mathbb{Z}$, e $MDC(m,n) = 1$ é um sistema completo de resíduos módulo $n$.
\end{theorem}
\textbf{Demonstração:}
Primeiro provaremos que $\forall a \in \mathbb{Z}, \exists! s_i \in S \mid a \equiv s_i (mod$ $n)$.

Tome um inteiro $a$ qualquer e a Congruência Linear: $(a-p)\equiv xm(mod$ $n)$. Pelo \textbf{Corolário} \autoref{teorema_congruencia_linear_ida_volta} sabemos que essa Congruência Linear tem solução, já que $MDC(m,n)=1$. Assim:

$(a-p)\equiv xm(mod$ $n) \Rightarrow a\equiv xm+p(mod$ $n) \Rightarrow a\equiv im + p (mod$ $n), i=x\bmod n$

$\Rightarrow a\equiv s_i(mod$ $n)$

Agora provaremos que $s_i \not\equiv s_j (mod $ $n)$ para $i \neq j$.

Tome $s_i$ e $s_j$ em $S$ com $i\neq j$, $0 < |i-j| < n$. Claramente $(i-j)\not\equiv 0(mod$ $n)$, já que que $i$ e $j$ são distintos e $0 \leq i,j < n$.
Portanto $(i-j)m\not\equiv 0(mod$ $n)$, já que $MDC(m,n)=1$, e assim:

$(i-j)m\not\equiv 0(mod$ $n) \Rightarrow im \not\equiv jm(mod$ $n) \Rightarrow im+p \not\equiv jm+p(mod$ $n)$

$\Rightarrow s_i \not\equiv s_j(mod$ $n)$.

Disso segue que $S$ é um sistema completo de resíduos módulo $n$. $\square$


%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Teoremas de Fermat e de Wilson}% e do Resto Chinês}

\subsection{Teorema de Fermat}

\begin{theorem}[Pequeno Teorema de Fermat]\label{teorema_fermat}
Dado um número primo qualquer $p$, temos que: 
$a^{p-1} \equiv 1 (\bmod$ $p), \forall a \in \mathbb{Z} \mid MDC(a, p) = 1$
\end{theorem}
\textbf{Demonstração:}
Tome os conjuntos $S = \{s_0, s_1, s_2, ..., s_{p-1}\}$, com $s_i = ai$, e $T = \{0, 1, 2,..., p-1\}$. 
Claramente o conjunto $T$ é um \textit{Sistema completo de resíduos módulo $p$}.
Pelo \autoref{sistemo_completp_residuo} sabemos que $S$ também é um \textit{Sistema completo de resíduos módulo $p$},
e assim, $\forall s_i\in S$, $\exists! t_j\in T, 0\leq t_j\leq(p-1)$, tal que $s_i\equiv t_j(mod$ $p)$. Dessa informação podemos derivar a seguinte congruência modular:

$s_1.s_2.s_3...s_{p-1} \equiv t_1.t_2.t_3...t_{p-1} (mod$ $p)$ ($\triangleright$ Observe que o correspondente a $s_0$ é $t_0$)

$\Rightarrow a.2a.3a....(p-1)a \equiv 1.2.3....(p-1) (mod$ $p) \Rightarrow a^{p-1}(p-1)! \equiv (p-1)! (mod$ $p)$

E aplicando os \textbf{Corolários} \autoref{mdc_primo_fatorial} e \textbf{Proposição} \autoref{corolario_implicacao_mdc}, temos:

$a^{p-1}\equiv 1(mod$ $p)$. $\square$
\\


\begin{theorem}\label{teorema_fermat_expansao}
Dados os inteiros $a$ e $b$ quaisquer e um número primo $p$, com $MDC(a, p) = 1$, temos que:

$a^{b} \equiv a^{b \bmod (p-1)} (\bmod$ $p)$
\end{theorem}
\textbf{Demonstração:}
Pelo \autoref{algoritmo_divisao} podemos escrever $b=q(p-1)+r$, onde $r=b\bmod(p-1)$. Assim temos:

$a^b = a^{q(p-1)+r} = a^{q(p-1)}a^r = (a^{p-1})^qa^r \Rightarrow a^b \equiv (a^{p-1})^qa^r (mod$ $p)$ 

Pelo \autoref{teorema_fermat} temos $a^{p-1} \equiv 1 (\bmod$ $p)$. Logo:

$a^b \equiv (1)^qa^r \equiv a^r \equiv a^{b \bmod (p-1)} (mod$ $p)$. $\square$
\\

\subsection{Inverso Multiplicativo Modular}

\begin{definition}
Um inteiro $x$ é chamado de \textit{Inverso Multiplicativo} de $a$ módulo $m$, se $ax\equiv1$ $(mod$ $m)$, para $a$ e $m$ inteiros.
\end{definition}


\begin{theorem}\label{inveso_multiplicativo_modular}
Se $p$ é primo e $a$ é primo entre si com $p$, então: $a^{p-2} \equiv a^{-1}$ $(mod$ $p)$, ou seja, $a^{p-2}$ é inverso multiplicativo
de $a$ módulo $p$.
\end{theorem}
\textbf{Demonstração:}
Pelo \autoref{teorema_fermat} sabemos que $a^{p-1}\equiv1$ $(mod$ $p)$. Sabemos também que existe um inverso multiplicativo $a^{-1}$
de $a$ módulo $p$, já que $a$ e $p$ são primos entre si. Desse modo, temos que:

$a^{p-1}\equiv1$ $(mod$ $p) \Rightarrow a^{p-1}a^{-1} \equiv 1.a^{-1}$ $(mod$ $p) \Rightarrow a^{p-2}\equiv a^{-1}$ $(mod$ $p)$.$\square$


\subsection{Teorema de Wilson}

\begin{proposition}\label{proposicao_teorema_wilson}
Se $p$ é um número primo, e $a$ um inteiro tal que $1\leq a\leq p-2$, então:

$a^2 \equiv 1$ $(mod$ $p) \Leftrightarrow a = \pm 1 $
\end{proposition}
\textbf{Demonstração:}
Claramente se $a = \pm 1$ então $a^2 \equiv 1$ $(mod$ $p)$. Provaremos então somente a ida da implicação.

Sabemos que $a^2 \equiv 1$ $(mod$ $p)$, desse modo temos que:
\\

$a^2 \equiv 1$ $(mod$ $p) \Rightarrow (a^2-1) \equiv 0$ $(mod$ $p) \Rightarrow (a-1)(a+1) \equiv 0$ $(mod$ $p)$
\\
$\Rightarrow (a-1)\equiv0$ $(mod$ $p)$ ou $(a+1)\equiv0$ $(mod$ $p)$
\\
$\Rightarrow a\equiv1$ $(mod$ $p)$ ou $a\equiv-1$ $(mod$ $p) \Rightarrow a=1$ ou $a=-1$. $\square$

\begin{theorem}[Teorema de Wilson]
Se $p$ é um número primo, então $(p-1)! \equiv -1$ $(mod$ $p)$
\end{theorem}
\textbf{Demonstração:}
Para $p=2$ o resultado é trivial, então assumiremos que $p\geq 3$.

Pela \textbf{Proposição} \autoref{proposicao_teorema_wilson} sabemos que $a^2 \equiv 1$ $(mod$ $p) \Leftrightarrow a = \pm 1$ 
para $1\leq a\leq p-2$, e assim o inverso multiplicativo de um número $b$ em $2\leq b\leq p-2$ é diferente de $b$. Podemos então
agrupar os $\frac{p-3}{2}$ pares de inversos multiplicativos no intervalo $[2,p-2]$ de modo que teremos: $2.3....(p-2) \equiv1$ $(mod$ $p)$.

Desse mode, temos que:

$(p-1)! \equiv 2.3.4...(p-2)(p-1) \equiv (p-1) \equiv -1$ $(mod$ $p)$. $\square$

%\subsection{Teorema do Resto Chinês}

%\begin{theorem}[Teorema do Resto Chinês]
%Tome o sistema de congruências lineares:

%$a_1x \equiv c_1 (mod$ $m_1)$

%$a_2x \equiv c_2 (mod$ $m_2)$

%$a_3x \equiv c_3 (mod$ $m_3)$

%$...$

%$a_nx \equiv c_n (mod$ $m_n)$\\

%Em que $c_i \in \mathbb{Z}$, $MDC(a_i,m_i) = 1$, e $MDC(m_i, m_j) = 1$ para $i \neq j$
%Nessas condições o sistema acima tem solução única módulo $M$, em que $M = m_1m_2m_3...m_n$.
%\end{theorem}
%\textbf{Demonstração:}
%TODO


%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Exponenciação}

%----------------------------------------------------------------------------------------
\subsection{Exponenciação Binária}

\textit{Exponenciação Binária} é um algoritmo muito usado em \textit{Ciência da Computação} principalmente no campo da \textit{Criptografia}.

O algoritmo recebe inteiros $a$ e $b$, e calcula $a^b$, usando divisão e conquista sobre a seguinte equação:
\[
 a^b = 
  \begin{cases} 
   1& \text{se } b = 0 \\
   (a^{\lfloor \frac{b}{2} \rfloor})^2& \text{se } b \text{ for par} \\
   a(a^{\lfloor \frac{b}{2} \rfloor})^2& \text{se } b \text{ for ímpar} 
  \end{cases}
\]

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Exponenciação Binária}
\begin{algorithmic}[1]
\Procedure{$EXPBIN (a, b)$}{}
\If {$b = 0$}
\State \Return $1$
\EndIf 
\\
\State $pot \gets EXPBIN(a, \lfloor \frac{b}{2} \rfloor)$
\State $pot \gets pot^2$
\\
\If {$b \equiv 0 (mod$ $2)$}
\State \Return $pot$
\Else
\State \Return $a(pot)$
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
O tempo $T(a,b)$ que o algoritmo consome é dado por: $T(a,b) = T(a,b/2)+O(1)$, em que $T(a,0) = O(1)$.

Expandindo essa recursão é fácil perceber que a complexidade do algoritmo é $O(\log b)$.


%----------------------------------------------------------------------------------------
\subsection{Exponenciação Binária Modular}

\textit{Exponenciação Binária Modular} é uma variação do algoritmo \textit{Exponenciação Binária} que calcula $a^b\bmod m$, para dodos inteiros $a$, $b$, e $m$. Em geral \textit{Exponenciação Binária Modular} é mais usado que \textit{Exponenciação Binária}, 
pelo fato da expressão $a^b$ crescer rapidamente e causar \textit{overflow}.\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Exponenciação Modular}\label{exponenciacao_modular}
\begin{algorithmic}[1]
\Procedure{$EXPMOD (a, b, m)$}{}
\If {$b = 0$}
\State \Return $1$
\EndIf 
\\
\State $pot \gets EXPMOD(a, \lfloor \frac{b}{2} \rfloor, m)$
\State $pot \gets pot^2 \mod m$
\\
\If {$b \equiv 0 (mod$ $2)$}
\State \Return $pot$
\Else
\State \Return $a(pot) \mod m$
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
O tempo $T(a,b,m)$ que o algoritmo consome é dado por: $T(a,b,m) = T(a,b/2,m)+O(1)$, em que $T(a,0,m) = O(1)$.

Assim esse algoritmo tem a mesma complexidade $O(\log b)$ da \textit{Exponenciação Binária}.

%----------------------------------------------------------------------------------------
\subsection{Exponenciação de Matriz}

\textit{Exponenciação de Matriz} é uma outra variação do algoritmo \textit{Exponenciação Binária} que calcula $A^b\bmod m$, para dados inteiros $b$ e $m$ e a matriz quadrada $A_{n,n}$. 

\begin{definition}
A expressão "$A \bmod m$", em que $A$ é uma matriz e $m$ um inteiro qualquer, representa uma matriz $B$ com as mesmas dimensões que $A$, tal que: $B_{ij} = A_{ij} \bmod m$, $\forall B_{ij} \in B$.
\end{definition}

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Exponenciação de Matriz}\label{exponenciacao_matrix}
\begin{algorithmic}[1]
\Procedure{$EXPMAT (A, b, m)$}{}
\If {$b = 0$}
\State \Return $I$ \Comment {$I$ representa a matriz identidade de dimensão $n$}
\EndIf 
\\
\State $P \gets EXPMAT(A, \lfloor \frac{b}{2} \rfloor, m)$
\State $P \gets P^2 \mod m$
\\
\If {$b \equiv 0 (mod$ $2)$}
\State \Return $P$
\Else
\State \Return $A(P) \mod m$
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
A recursão desse algoritmo é similar a recursão da \textit{Exponenciação Binária}, exceto pela operação de produto, que nesse caso são produtos de matrizes. O tempo gasto para multiplicar duas matrizes quadradas de dimensão $n$ é $O(n^3)$. Assim, a complexidade total 
do algoritmo é $O(n^3 \log b)$.




%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Problemas Propostos}



%----------------------------------------------------------------------------------------
\subsection{SPOJ-DCEPC11B}
\href{http://www.spoj.com/problems/DCEPC11B/}{DCEPC11B - Boring Factorials}\\

\textbf{Resumo:}
São dados inteiros $N$ ($1\leq N \leq 2.10^9$) e o número primo $P$ ($1 < P \leq 2.10^9)$, de tal forma que a diferença entre $N$ e $P$ é pequena.
O problema consiste em calcular $N! \bmod P$.
\\

\textbf{Solução:}
Pelo \textbf{Teorema de Wilson} sabemos que $(P-1)! \equiv -1 (mod$ $P)$. 

Temos que o problema pode ser dividido em dois casos:
\newline

\textbf{Caso 1:} \textit{$N \geq P$}

Nesse caso, teremos que:

$N! \equiv (P-1)!\prod_{i=P}^{N}i \equiv (-1)\prod_{i=P}^{N}i$ $(mod$ $P)$. 
\newline

\textbf{Caso 2:} \textit{$N < P$}

Nesse caso, teremos que:

$N! \equiv (P-1)!\prod_{i=N+1}^{P-1}i^{-1} \equiv (-1)\prod_{i=N+1}^{P-1}i^{-1}$ $(mod$ $P)$. 
\\

Para resolver o \textbf{caso 1} só precisamos aplicar o \textbf{Teorema de Wilson} e construir o produto $\prod_{i=P}^{N}i$ iterativamente.
Para o \textbf{caso 2}, podemos usar o \textbf{Pequeno Teorema de Fermat} para calcular o inverso multiplicativo dos números no produto $\prod_{i=N+1}^{P-1}i^{-1}$. 
\newline 

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Boring Factorials}
\begin{algorithmic}[1]
\Procedure{BoringFact (N, P)}{}
\State $solution \gets -1$
\\
\If {$N \geq P$}
\For {$(i = P \text{; } i \leq N \text{; } i++)$}
\State $solution \gets (solution.i) \bmod P$
\EndFor
\Else
\For {$(i = N+1 \text{; } i \leq P-1 \text{; } i++)$}
\State $inverse \gets MODEXP(i, P-2, P)$ \Comment {\autoref{inveso_multiplicativo_modular}}
\State $solution \gets (solution$ . $inverse) \bmod P$
\EndFor
\EndIf
\\
\State \Return $solution$

\EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{Análise:}
A complexidade do laço da linha $5$ é dado por $O(N-P)$. Já o laço da linha $8$ consome tempo proporcional a $O((P-N)\log P)$, já que
a complexidade do algoritmo $MODEXP()$ na linha $9$ é $O(\log P)$.

Assim, a complexidade total do algoritmo é $O(|N-P|\log P)$.



%----------------------------------------------------------------------------------------
\subsection{CodeChef-IITK2P10}
\href{https://www.codechef.com/problems/IITK2P10}{IITK2P10 - Chef and Pattern}\\


\textbf{Resumo:}
Tome a seguinte função $f_K:\mathbb{N}^* \longmapsto \mathbb{N}$:

\[
 f_K(x) = 
  \begin{cases} 
   1 & \text{se } x = 1 \\
   K & \text{se } x = 2 \\
   \prod_{i=1}^{x-1}f_K(i) & \text{se } x \geq 3
  \end{cases}
\]

São dados dois números inteiros $N$, $K$ ($1 \leq N \leq 10^9$, $1 \leq K \leq 10^5$). O problema consiste em calcular a expressão: $f_K(N) \bmod p$, em que $p = (10^9+7)$.
\\

\textbf{Solução:}
Escrevendo os valores dos primeiros termos que a função assume, temos: $f_K(1)=1, f_K(2)=K, f_K(3)=K, f_K(4)=K^2, f_K(5)=K^4, f_K(6)=K^8, f_K(7)=K^{16}$.

Provaremos, por indução, que $f_K(N) = K^{2^{N-3}}, N \geq 3$.

Para os primeiros termos essa expressão é trivialmente verificada.

Assuma que a expressão funciona para algum número natural qualquer $(R-1) \geq 3$ ($f_K(R-1) = K^{2^{R-4}}$).

Nessas condições temos que: 

$f_K(R) = \prod_{i=1}^{R-1}f_K(i) = 1.K.\prod_{i=3}^{R-1}f_K(i) = K\prod_{i=3}^{R-1}K^{2^{i-3}} = K\prod_{j=0}^{R-4}K^{2^j}$

$f_K(R) = KK^{\sum_{j=0}^{R-4}2^j} = KK^{2^{R-3}-1} = K^{2^{R-3}}$ $\square$

Para calcular o valor de $f_K(N) \bmod p$, podemos aplicar o \autoref{teorema_fermat_expansao}, já que $p$ é um número primo e $MDC(p, K) = 1$:

$f_K(N) \bmod p = K^{2^{N-3}} \bmod p = K^{2^{N-3} \bmod (p-1)} \bmod p$ 

Reduzindo o problema, dessa maneira, em calcular: $K^{2^{N-3}} \bmod (10^9+7)$.
\\

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{Chef and Pattern}
\begin{algorithmic}[1]
\Procedure{f (N, K)}{}
\State $p \gets (10^9+7)$
\State $exp \gets EXPMOD(2, N-3, p-1)$ \Comment{\textbf{Algoritmo} $\autoref{exponenciacao_modular}$}
\State $solution \gets EXPMOD(K, exp, p)$ \Comment{$solution = K^{2^{N-3} \bmod (p-1)} \bmod p$}
\State \Return{$solution$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Como vimos anteriormente, as linhas $3$ e $4$ do algoritmo consomem tempo proporcional à $O(n \log n)$, e assim a complexidade total é $O(n \log n)$.




%----------------------------------------------------------------------------------------
\subsection{CodeChef-CSUMD}
\href{https://www.codechef.com/JULY12/problems/CSUMD}{SUMD - My Fair Coins}\\


\textbf{Resumo:}
Existe um número infinito de moedas de dois tipos: as de $1$ centavo, e as de $2$ centavos. 
Todas as moedas tem dois lados (\textit{cara} e \textit{coroa}) que representam o valor da moeda. 

É dado um inteiro $N$ ($1 \leq N \leq 10^9$). 
O problema consiste em calcular o número de arranjos lineares dessas moedas, de modo que a soma das moedas é igual à $N$.
A única restrição é que a primeira moeda de cada arranjo seja \textit{cara}. 

Como esse número pode ser muito grande, a resposta tem que ser dada módulo $m$ ($m = 10^7+9$).
\\

\textbf{Solução:}
Tome $f_1(N)$ como sendo o número de arranjos lineares com a primeira moeda sendo \textit{cara}. Analogamente, tome $f_2(N)$
como sendo o número de arranjos lineares com a primeira moeda sendo \textit{coroa}. Por último, tome $f(N) = f_1(N)+f_2(N)$, como
sendo o número total de arranjos cuja a soma das moedas é $N$.

Nessas condições temos as seguintes \textbf{Proposições}:
\\

\textbf{Proposição 1:} $f_1(N) = f_2(N)$

\textbf{Prova:} Para cada arranjo em $f_1$, se trocarmos a primeira moeda de \textit{cara} para \textit{coroa}, teremos um arranjo correspondente em $f_2$. E assim, há uma bijeção de $f_1$ para $f_2$.
\\

\textbf{Proposição 2:} $f_1(N) = f_1(N-1) + f_2(N-1) + f_1(N-2) + f_2(N-2)$

\textbf{Prova: }Tome um arranjo $A$ qualque em $f_1$. A primeira moeda de $A$ pode ser tanto uma moeda \textit{cara} de $1$ centavo,
como uma moeda \textit{cara} de $2$ centavos. O número de arranjos que começam com a moeda de $1$ centavo é $f(N-1)$ e o número de arranjos que começam com a moeda de $2$ centavos é $f(N-2)$. Assim temos:

$f_1(N) = f(N-1) + f(N-2) = f_1(N-1) + f_2(N-1) + f_1(N-2) + f_2(N-2)$.
\\


\textbf{Proposição 3:} $f_1(N) = 2(f_1(N-1) + f_1(N-2))$

\textbf{Prova: } Decorrente das \textbf{Proposições 1} e \textbf{2}.
\\

Claramente $f_1(1) = 1$, e $f_1(2) = 3$. Mostraremos um modo elegante de calcular $f_1(N)$ usando \textit{Exponenciação de Matrizes}.
Tome a matriz $A$ com as seguintes entradas:

\[ A_{2,2} = 
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}
\]

Teremos então que:

\[ 
\begin{bmatrix}
       f_1(N) & f_1(N-1)
\end{bmatrix}
=
\begin{bmatrix}
       f_1(N-1) & f_1(N-2)
\end{bmatrix}
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}
\]


\[ 
\begin{bmatrix}
       f_1(N) & f_1(N-1)
\end{bmatrix}
=
\bigg(
\begin{bmatrix}
       f_1(N-2) & f_1(N-3)
\end{bmatrix}
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}
\bigg)
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}
\]


\[ 
\begin{bmatrix}
       f_1(N) & f_1(N-1)
\end{bmatrix}
=
\begin{bmatrix}
       f_1(N-2) & f_1(N-3)
\end{bmatrix}
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}^2
\]

Expandindo essa recursão até a base, teremos:

\[ 
\begin{bmatrix}
       f_1(N) & f_1(N-1)
\end{bmatrix}
=
\begin{bmatrix}
       f_1(2) & f_1(1)
\end{bmatrix}
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}^{N-2}
\]


\[ 
\begin{bmatrix}
       f_1(N) & f_1(N-1)
\end{bmatrix}
=
\begin{bmatrix}
       3 & 1
\end{bmatrix}
\begin{bmatrix}
       2 & 1           \\[0.3em]
       2 & 0    
\end{bmatrix}^{N-2}
\]
\clearpage

\textbf{Pseudocódigo:}
\begin{algorithm}
\caption{My Fair Coins}
\begin{algorithmic}[1]
\Procedure{$f_1 (N, m)$}{}
\If {$N = 1$}
\State \Return $1$
\EndIf
\\
\If {$N = 2$}
\State \Return $3$
\EndIf
\\
\State $A \gets 
\begin{bmatrix}
2 & 1           \\[0.3em]
2 & 0
\end{bmatrix}
$
\\
\State $B \gets EXPMAT(A, N-2, m)$ \Comment{\textbf{Algoritmo} $\autoref{exponenciacao_matrix}$}
\\
\State \Return{$3B_{0,0} + 1B_{1,0}$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Análise:}
Esse algoritmo tem a mesma complexidade do \textbf{Algoritmo} \autoref{exponenciacao_matrix}, ou seja, $O(n^3 \log N)$ (onde $n$ é a dimensão da matriz).
Como nesse problema a matriz é sempre quadrada de dimensão $n=2$, temos que a complexidade final do algoritmo será $O(\log N)$.

